<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[星晨入梦]]></title>
  <link href="http://blog.cxstars.com/atom.xml" rel="self"/>
  <link href="http://blog.cxstars.com/"/>
  <updated>2017-03-03T13:18:19+08:00</updated>
  <id>http://blog.cxstars.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[unsupervised learning]]></title>
    <link href="http://blog.cxstars.com/14890706857877.html"/>
    <updated>2017-03-09T22:44:45+08:00</updated>
    <id>http://blog.cxstars.com/14890706857877.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">中英字幕</h2>

<p><strong>视频用中文字幕(捂脸,英文太渣),一边看视频一边看字幕文件,时间+中项对照</strong><br/>
<a href="https://www.coursera.org/learn/machine-learning/lecture/olRZo/unsupervised-learning">https://www.coursera.org/learn/machine-learning/lecture/olRZo/unsupervised-learning</a><br/>
0:00<br/>
In this video, we&#39;ll talk about the second major type of machine learning problem, called Unsupervised Learning. <br/>
在这段视频中 我们要讲 第二种主要的机器学习问题 叫做无监督学习 <br/>
0:06<br/>
In the last video, we talked about Supervised Learning. Back then, recall data sets that look like this, where each example was labeled either as a positive or negative example, whether it was a benign or a malignant tumor. <br/>
在上一节视频中 我们已经讲过了监督学习 回想起上次的数据集 每个样本 都已经被标明为 正样本或者负样本 即良性或恶性肿瘤 <br/>
0:20<br/>
So for each example in Supervised Learning, we were told explicitly what is the so-called right answer, whether it&#39;s benign or malignant. In Unsupervised Learning, we&#39;re given data that looks different than data that looks like this that doesn&#39;t have any labels or that all has the same label or really no labels. <br/>
因此 对于监督学习中的每一个样本 我们已经被清楚地告知了 什么是所谓的正确答案 即它们是良性还是恶性 在无监督学习中 我们用的数据会和监督学习里的看起来有些不一样 在无监督学习中 没有属性或标签这一概念 也就是说所有的数据 都是一样的 没有区别 <br/>
0:39<br/>
So we&#39;re given the data set and we&#39;re not told what to do with it and we&#39;re not told what each data point is. Instead we&#39;re just told, here is a data set. Can you find some structure in the data? Given this data set, an Unsupervised Learning algorithm might decide that the data lives in two different clusters. And so there&#39;s one cluster <br/>
所以在无监督学习中 我们只有一个数据集 没人告诉我们该怎么做 我们也不知道 每个数据点究竟是什么意思 相反 它只告诉我们 现在有一个数据集 你能在其中找到某种结构吗？ 对于给定的数据集 无监督学习算法可能判定 该数据集包含两个不同的聚类 你看 这是第一个聚类 <br/>
0:59<br/>
and there&#39;s a different cluster. <br/>
然后这是另一个聚类 <br/>
1:01<br/>
And yes, Supervised Learning algorithm may break these data into these two separate clusters. <br/>
你猜对了 无监督学习算法 会把这些数据分成两个不同的聚类 <br/>
1:06<br/>
So this is called a clustering algorithm. And this turns out to be used in many places. <br/>
所以这就是所谓的聚类算法 实际上它被用在许多地方 <br/>
1:11<br/>
One example where clustering is used is in Google News and if you have not seen this before, you can actually go to this URL news.google.com to take a look. What Google News does is everyday it goes and looks at tens of thousands or hundreds of thousands of new stories on the web and it groups them into cohesive news stories. <br/>
我们来举一个聚类算法的栗子 Google 新闻的例子 如果你还没见过这个页面的话 你可以到这个URL news.google.com 去看看 谷歌新闻每天都在干什么呢？ 他们每天会去收集 成千上万的 网络上的新闻 然后将他们分组 组成一个个新闻专题 <br/>
1:30<br/>
For example, let&#39;s look here. <br/>
比如 让我们来看看这里 <br/>
1:33<br/>
The URLs here link to different news stories about the BP Oil Well story. <br/>
这里的URL链接 连接着不同的 有关BP油井事故的报道 <br/>
1:41<br/>
So, let&#39;s click on one of these URL&#39;s and we&#39;ll click on one of these URL&#39;s. What I&#39;ll get to is a web page like this. Here&#39;s a Wall Street Journal article about, you know, the BP Oil Well Spill stories of &quot;BP Kills Macondo&quot;, which is a name of the spill and if you click on a different URL <br/>
所以 让我们点击 这些URL中的一个 恩 让我们点一个 然后我们会来到这样一个网页 这是一篇来自华尔街日报的 有关……你懂的 有关BP油井泄漏事故的报道 标题为《BP杀死了Macondo》 Macondo 是个地名 就是那个漏油事故的地方 如果你从这个组里点击一个不同的URL <br/>
2:00<br/>
from that group then you might get the different story. Here&#39;s the CNN story about a game, the BP Oil Spill, <br/>
那么你可能会得到不同的新闻 这里是一则CNN的新闻 是一个有关BP石油泄漏的视频 <br/>
2:07<br/>
and if you click on yet a third link, then you might get a different story. Here&#39;s the UK Guardian story about the BP Oil Spill. <br/>
如果你再点击第三个链接 又会出现不同的新闻 这边是英国卫报的报道 也是关于BP石油泄漏 <br/>
2:16<br/>
So what Google News has done is look for tens of thousands of news stories and automatically cluster them together. So, the news stories that are all about the same topic get displayed together. It turns out that clustering algorithms and Unsupervised Learning algorithms are used in many other problems as well. <br/>
所以 谷歌新闻所做的就是 去搜索成千上万条新闻 然后自动的将他们聚合在一起 因此 有关同一主题的 新闻被显示在一起 实际上 聚类算法和无监督学习算法 也可以被用于许多其他的问题 <br/>
2:35<br/>
Here&#39;s one on understanding genomics. <br/>
这里我们举个它在基因组学中的应用 <br/>
2:38<br/>
Here&#39;s an example of DNA microarray data. The idea is put a group of different individuals and for each of them, you measure how much they do or do not have a certain gene. Technically you measure how much certain genes are expressed. So these colors, red, green, gray and so on, they show the degree to which different individuals do or do not have a specific gene. <br/>
下面是一个关于基因芯片的例子 基本的思想是 给定一组不同的个体 对于每个个体 检测它们是否拥有某个特定的基因 也就是说，你要去分析有多少基因显现出来了 因此 这些颜色 红 绿 灰 等等 它们 展示了这些不同的个体 是否拥有一个特定基因 的不同程度 <br/>
3:02<br/>
And what you can do is then run a clustering algorithm to group individuals into different categories or into different types of people. <br/>
然后你能做的就是 运行一个聚类算法 把不同的个体归入不同的类 或归为不同类型的人 <br/>
3:10<br/>
So this is Unsupervised Learning because we&#39;re not telling the algorithm in advance that these are type 1 people, those are type 2 persons, those are type 3 persons and so on and instead what were saying is yeah here&#39;s a bunch of data. I don&#39;t know what&#39;s in this data. I don&#39;t know who&#39;s and what type. I don&#39;t even know what the different types of people are, but can you automatically find structure in the data from the you automatically cluster the individuals into these types that I don&#39;t know in advance? Because we&#39;re not giving the algorithm the right answer for the examples in my data set, this is Unsupervised Learning. <br/>
这就是无监督学习 我们没有提前告知这个算法 这些是第一类的人 这些是第二类的人 这些是第三类的人等等 相反我们只是告诉算法 你看 这儿有一堆数据 我不知道这个数据是什么东东 我不知道里面都有些什么类型 叫什么名字 我甚至不知道都有哪些类型 但是 请问你可以自动的找到这些数据中的类型吗？ 然后自动的 按得到的类型把这些个体分类 虽然事先我并不知道哪些类型 因为对于这些数据样本来说 我们没有给算法一个 正确答案 所以 这就是无监督学习 <br/>
3:44<br/>
Unsupervised Learning or clustering is used for a bunch of other applications. <br/>
无监督学习或聚类算法在其他领域也有着大量的应用 <br/>
3:48<br/>
It&#39;s used to organize large computer clusters. <br/>
它被用来组织大型的计算机集群 <br/>
3:51<br/>
I had some friends looking at large data centers, that is large computer clusters and trying to figure out which machines tend to work together and if you can put those machines together, you can make your data center work more efficiently. <br/>
我有一些朋友在管理 大型数据中心 也就是 大型计算机集群 并试图 找出哪些机器趋向于 协同工作 如果你把这些机器放在一起 你就可以让你的数据中心更高效地工作 <br/>
4:04<br/>
This second application is on social network analysis. <br/>
第二种应用是用于社交网络的分析 <br/>
4:07<br/>
So given knowledge about which friends you email the most or given your Facebook friends or your Google+ circles, can we automatically identify which are cohesive groups of friends, also which are groups of people that all know each other? <br/>
所以 如果可以得知 哪些朋友你用email联系的最多 或者知道你的Facebook好友 或者你Google+里的朋友 知道了这些之后 我们是否可以自动识别 哪些是很要好的朋友组 哪些仅仅是互相认识的朋友组 <br/>
4:22<br/>
Market segmentation. <br/>
还有在市场分割中的应用 <br/>
4:24<br/>
Many companies have huge databases of customer information. So, can you look at this customer data set and automatically discover market segments and automatically <br/>
许多公司拥有庞大的客户信息数据库 那么 给你一个 客户数据集 你能否 自动找出不同的市场分割 <br/>
4:33<br/>
group your customers into different market segments so that you can automatically and more efficiently sell or market your different market segments together? <br/>
并自动将你的客户分到不同的 细分市场中 从而有助于我在 不同的细分市场中 进行更有效的销售 <br/>
4:44<br/>
Again, this is Unsupervised Learning because we have all this customer data, but we don&#39;t know in advance what are the market segments and for the customers in our data set, you know, we don&#39;t know in advance who is in market segment one, who is in market segment two, and so on. But we have to let the algorithm discover all this just from the data. <br/>
这也是无监督学习 我们现在有 这些客户数据 但我们预先并不知道 有哪些细分市场 而且 对于我们数据集的某个客户 我们也不能预先知道 谁属于细分市场一 谁又属于细分市场二等等 但我们必须让这个算法自己去从数据中发现这一切 <br/>
5:01<br/>
Finally, it turns out that Unsupervised Learning is also used for surprisingly astronomical data analysis and these clustering algorithms gives surprisingly interesting useful theories of how galaxies are formed. All of these are examples of clustering, which is just one type of Unsupervised Learning. Let me tell you about another one. I&#39;m gonna tell you about the cocktail party problem. <br/>
最后 事实上无监督学习也被用于 天文数据分析 通过这些聚类算法 我们发现了许多 惊人的、有趣的 以及实用的 关于星系是如何诞生的理论 所有这些都是聚类算法的例子 而聚类只是无监督学习的一种 现在让我来告诉你另一种 我先来介绍一下鸡尾酒宴问题 <br/>
5:26<br/>
So, you&#39;ve been to cocktail parties before, right? Well, you can imagine there&#39;s a party, room full of people, all sitting around, all talking at the same time and there are all these overlapping voices because everyone is talking at the same time, and it is almost hard to hear the person in front of you. So maybe at a cocktail party with two people, <br/>
恩 我想你参加过鸡尾酒会的 是吧？ 嗯 想象一下 有一个宴会 有一屋子的人 大家都坐在一起 而且在同时说话 有许多声音混杂在一起 因为每个人都是在同一时间说话的 在这种情况下你很难听清楚你面前的人说的话 因此 比如有这样一个场景 宴会上只有两个人 <br/>
5:45<br/>
two people talking at the same time, and it&#39;s a somewhat small cocktail party. And we&#39;re going to put two microphones in the room so there are microphones, and because these microphones are at two different distances from the speakers, each microphone records a different combination of these two speaker voices. <br/>
两个人 同时说话 恩 这是个很小的鸡尾酒宴会 我们准备好了两个麦克风 把它们放在房间里 然后 因为这两个麦克风距离这两个人 的距离是不同的 每个麦克风都记录下了 来自两个人的声音的不同组合 <br/>
6:05<br/>
Maybe speaker one is a little louder in microphone one and maybe speaker two is a little bit louder on microphone 2 because the 2 microphones are at different positions relative to the 2 speakers, but each microphone would cause an overlapping combination of both speakers&#39; voices. <br/>
也许A的声音 在第一个麦克风里的声音会响一点 也许B的声音 在第二个麦克风里会比较响一些 因为2个麦克风 的位置相对于 2个说话者的位置是不同的 但每个麦克风都会录到 来自两个说话者的重叠部分的声音 <br/>
6:23<br/>
So here&#39;s an actual recording <br/>
这里有一个 <br/>
6:26<br/>
of two speakers recorded by a researcher. Let me play for you the first, what the first microphone sounds like. One (uno), two (dos), three (tres), four (cuatro), five (cinco), six (seis), seven (siete), eight (ocho), nine (nueve), ten (y diez). <br/>
来自一个研究员录下的两个说话者的声音 让我先放给你听第一个 这是第一个麦克风录到的录音： 一 (UNO) 二 (DOS) 三 (TRES) 四 (CUATRO) 五 (CINCO) 六 (SEIS) 七 (SIETE) 八 (ocho) 九 (NUEVE) 十 (Y DIEZ) <br/>
6:41<br/>
All right, maybe not the most interesting cocktail party, there&#39;s two people counting from one to ten in two languages but you know. What you just heard was the first microphone recording, here&#39;s the second recording. <br/>
好吧 这大概不是什么有趣的酒会…… ……在这个酒会上 有两个人 各自从1数到10 但用的是两种不同语言 你刚才听到的是 第一个麦克风的录音 这里是第二个的： <br/>
6:57<br/>
Uno (one), dos (two), tres (three), cuatro (four), cinco (five), seis (six), siete (seven), ocho (eight), nueve (nine) y diez (ten). So we can do, is take these two microphone recorders and give them to an Unsupervised Learning algorithm called the cocktail party algorithm, and tell the algorithm - find structure in this data for you. And what the algorithm will do is listen to these audio recordings and say, you know it sounds like the two audio recordings are being added together or that have being summed together to produce these recordings that we had. Moreover, what the cocktail party algorithm will do is separate out these two audio sources that were being added or being summed together to form other recordings and, in fact, here&#39;s the first output of the cocktail party algorithm. <br/>
一 (UNO) 二 (DOS) 三 (TRES) 四 (CUATRO) 五 (CINCO) 六 (SEIS) 七 (SIETE) 八 (ocho) 九 (NUEVE) 十 (Y DIEZ) 所以 我们能做的就是把 这两个录音输入 一种无监督学习算法中 称为“鸡尾酒会算法” 让这个算法 帮你找出其中蕴含的分类 然后这个算法 就会去听这些 录音 并且你知道 这听起​​来像 两个音频录音 被叠加在一起 所以我们才能听到这样的效果 此外 这个算法 还会分离出 这两个被 叠加到一起的 音频源 事实上 这是我们的鸡尾酒会算法的第一个输出 <br/>
7:39<br/>
One, two, three, four, five, six, seven, eight, nine, ten. <br/>
一 二 三 四 五 六 七 八 九 十 <br/>
7:47<br/>
So, I separated out the English voice in one of the recordings. <br/>
所以我在一个录音中 分离出了英文声音 <br/>
7:52<br/>
And here&#39;s the second of it. Uno, dos, tres, quatro, cinco, seis, siete, ocho, nueve y diez. Not too bad, to give you <br/>
这是第二个输出 Uno dos tres quatro cinco seis siete ocho nueve y diez 听起来不错嘛 <br/>
8:03<br/>
one more example, here&#39;s another recording of another similar situation, here&#39;s the first microphone : One, two, three, four, five, six, seven, eight, nine, ten. <br/>
再举一个例子 这是另一个录音 也是在一个类似的场景下 这是第一个麦克风的录音： 一 二 三 四 五 六 七 八 九 十 <br/>
8:16<br/>
OK so the poor guy&#39;s gone home from the cocktail party and he &#39;s now sitting in a room by himself talking to his radio. <br/>
OK 这个可怜的家伙从 鸡尾酒会回家了 他现在独自一人坐在屋里 对着录音机自言自语 <br/>
8:23<br/>
Here&#39;s the second microphone recording. <br/>
这是第二个麦克风的录音 <br/>
8:28<br/>
One, two, three, four, five, six, seven, eight, nine, ten. <br/>
一 二 三 四 五 六 七 八 九 十 <br/>
8:33<br/>
When you give these two microphone recordings to the same algorithm, what it does, is again say, you know, it sounds like there are two audio sources, and moreover, <br/>
当你把这两个麦克风录音 送给与刚刚相同的算法处理 它所做的还是 告诉你 这听起来有 两种音频源 并且 <br/>
8:42<br/>
the album says, here is the first of the audio sources I found. <br/>
算法说 这里是我找到的第一个音频源 <br/>
8:47<br/>
One, two, three, four, five, six, seven, eight, nine, ten. <br/>
一 二 三 四 五 六 七 八 九 十 <br/>
8:54<br/>
So that wasn&#39;t perfect, it got the voice, but it also got a little bit of the music in there. Then here&#39;s the second output to the algorithm. <br/>
恩 不是太完美 提取到了人声 但还有一点音乐没有剔除掉 这是算法的第二个输出 <br/>
9:10<br/>
Not too bad, in that second output it managed to get rid of the voice entirely. And just, you know, cleaned up the music, got rid of the counting from one to ten. <br/>
还好 在第二个输出中 它设法剔除掉了整个人声 只是清理了下音乐 剔除了从一到十的计数 <br/>
9:18<br/>
So you might look at an Unsupervised Learning algorithm like this and ask how complicated this is to implement this, right? It seems like in order to, you know, build this application, it seems like to do this audio processing you need to write a ton of code or maybe link into like a bunch of synthesizer Java libraries that process audio, seems like a really complicated program, to do this audio, separating out audio and so on. <br/>
所以 你可以看到 像这样的无监督学习算法 也许你想问 要实现这样的算法 很复杂吧？ 看起来 为了 构建这个应用程序 做这个音频处理 似乎需要写好多代码啊 或者需要链接到 一堆处理音频的Java库 貌似需要一个 非常复杂的程序 分离出音频等 <br/>
9:42<br/>
It turns out the algorithm, to do what you just heard, that can be done with one line of code - shown right here. <br/>
实际上 要实现你刚刚听到的效果 只需要一行代码就可以了 写在这里呢 <br/>
9:50<br/>
It take researchers a long time to come up with this line of code. I&#39;m not saying this is an easy problem, But it turns out that when you use the right programming environment, many learning algorithms can be really short programs. <br/>
当然 研究人员 花了很长时间才想出这行代码的 -^ 我不是说这是一个简单的问题 但事实上 如果你 使用正确的编程环境 许多学习 算法是用很短的代码写出来的 <br/>
10:03<br/>
So this is also why in this class we&#39;re going to use the Octave programming environment. <br/>
所以这也是为什么在 这门课中我们要 使用Octave的编程环境 <br/>
10:08<br/>
Octave, is free open source software, and using a tool like Octave or Matlab, many learning algorithms become just a few lines of code to implement. Later in this class, I&#39;ll just teach you a little bit about how to use Octave and you&#39;ll be implementing some of these algorithms in Octave. Or if you have Matlab you can use that too. <br/>
Octave是一个免费的 开放源码的软件 使用Octave或Matlab这类的工具 许多学习算法 都可以用几行代码就可以实现 在后续课程中 我会教你如何使用Octave 你会学到 如何在Octave中实现这些算法 或者 如果你有Matlab 你可以用它 <br/>
10:27<br/>
It turns out the Silicon Valley, for a lot of machine learning algorithms, what we do is first prototype our software in Octave because software in Octave makes it incredibly fast to implement these learning algorithms. <br/>
事实上 在硅谷 很多的机器学习算法 我们都是先用Octave 写一个程序原型 因为在Octave中实现这些 学习算法的速度快得让你无法想象 <br/>
10:38<br/>
Here each of these functions like for example the SVD function that stands for singular value decomposition; but that turns out to be a linear algebra routine, that is just built into Octave. <br/>
在这里 每一个函数 例如 SVD 意思是奇异值分解 但这其实是解线性方程 的一个惯例 它被内置在Octave软件中了 <br/>
10:49<br/>
If you were trying to do this in C++ or Java, this would be many many lines of code linking complex C++ or Java libraries. So, you can implement this stuff as C++ or Java or Python, it&#39;s just much more complicated to do so in those languages. <br/>
如果你试图 在C + +或Java中做这个 将需要写N多代码 并且还要连接复杂的C + +或Java库 所以 你可以在C++或 Java或Python中 实现这个算法 只是会 更加复杂而已 <br/>
11:03<br/>
What I&#39;ve seen after having taught machine learning for almost a decade now, is that, you learn much faster if you use Octave as your programming environment, and if you use Octave as your learning tool and as your prototyping tool, it&#39;ll let you learn and prototype learning algorithms much more quickly. <br/>
在教授机器学习 将近10年后 我得出的一个经验就是 如果你使用Octave的话 会学的更快 并且如果你用 Octave作为你的学习工具 和开发原型的工具 你的学习和开发过程 会变得更快 <br/>
11:22<br/>
And in fact what many people will do to in the large Silicon Valley companies is in fact, use an algorithm like Octave to first prototype the learning algorithm, and only after you&#39;ve gotten it to work, then you migrate it to C++ or Java or whatever. It turns out that by doing things this way, you can often get your algorithm to work much faster than if you were starting out in C++. <br/>
而事实上在硅谷 很多人会这样做 他们会先用Octave 来实现这样一个学习算法原型 只有在确定 这个算法可以工作后 才开始迁移到 C++ Java或其它编译环境 事实证明 这样做 实现的算法 比你一开始就用C++ 实现的算法要快多了 <br/>
11:44<br/>
So, I know that as an instructor, I get to say &quot;trust me on this one&quot; only a finite number of times, but for those of you who&#39;ve never used these Octave type programming environments before, I am going to ask you to trust me on this one, and say that you, you will, I think your time, your development time is one of the most valuable resources. <br/>
所以 我知道 作为一个老师 我不能老是念叨： “在这个问题上相信我“ 但对于 那些从来没有用过这种 类似Octave的编程环境的童鞋 我还是要请你 相信我这一次 我认为 你的时间 研发时间 是你最宝贵的资源之一 <br/>
12:04<br/>
And having seen lots of people do this, I think you as a machine learning researcher, or machine learning developer will be much more productive if you learn to start in prototype, to start in Octave, in some other language. <br/>
当见过很多的人这样做以后 我觉得如果你也这样做 作为一个机器学习的 研究者和开发者 你会更有效率 如果你学会先用Octave开发原型 而不是先用其他的编程语言来开发 <br/>
12:17<br/>
Finally, to wrap up this video, I have one quick review question for you. <br/>
最后 总结一下 这里有一个问题需要你来解答 <br/>
12:24<br/>
We talked about Unsupervised Learning, which is a learning setting where you give the algorithm a ton of data and just ask it to find structure in the data for us. Of the following four examples, which ones, which of these four do you think would will be an Unsupervised Learning algorithm as opposed to Supervised Learning problem. For each of the four check boxes on the left, check the ones for which you think Unsupervised Learning algorithm would be appropriate and then click the button on the lower right to check your answer. So when the video pauses, please answer the question on the slide. <br/>
我们谈到了无监督学习 它是一种学习机制 你给算法大量的数据 要求它找出数据中 蕴含的类型结构 以下的四个例子中 哪一个 您认为是 无监督学习算法 而不是监督学习问题 对于每一个选项 在左边的复选框 选中你认为 属于无监督学习的 选项 然后按一下右下角的按钮 提交你的答案 所以 当视频暂停时 请回答幻灯片上的这个问题 <br/>
13:01<br/>
So, hopefully, you&#39;ve remembered the spam folder problem. If you have labeled data, you know, with spam and non-spam e-mail, we&#39;d treat this as a Supervised Learning problem. <br/>
恩 没忘记垃圾邮件文件夹问题吧？ 如果你已经标记过数据 那么就有垃圾邮件和 非垃圾邮件的区别 我们会将此视为一个监督学习问题 <br/>
13:11<br/>
The news story example, that&#39;s exactly the Google News example that we saw in this video, we saw how you can use a clustering algorithm to cluster these articles together so that&#39;s Unsupervised Learning. <br/>
新闻故事的例子 正是我们在本课中讲到的 谷歌新闻的例子 我们介绍了你可以如何使用 聚类算法这些文章聚合在一起 所以这是无监督学习问题 <br/>
13:23<br/>
The market segmentation example I talked a little bit earlier, you can do that as an Unsupervised Learning problem because I am just gonna get my algorithm data and ask it to discover market segments automatically. <br/>
市场细分的例子 我之前有说过 这也是一个无监督学习问题 因为我是要 拿到数据 然后要求 它自动发现细分市场 <br/>
13:35<br/>
And the final example, diabetes, well, that&#39;s actually just like our breast cancer example from the last video. Only instead of, you know, good and bad cancer tumors or benign or malignant tumors we instead have diabetes or not and so we will use that as a supervised, we will solve that as a Supervised Learning problem just like we did for the breast tumor data. <br/>
最后一个例子 糖尿病 这实际上就像我们 上节课讲到的乳腺癌的例子 只不过这里不是 好的或坏的癌细胞 良性或恶性肿瘤我们 现在是有糖尿病或 没有糖尿病 所以这是 有监督的学习问题 像处理那个乳腺癌的问题一样 我们会把它作为一个 有监督的学习问题来处理 <br/>
13:58<br/>
So, that&#39;s it for Unsupervised Learning and in the next video, we&#39;ll delve more into specific learning algorithms and start to talk about just how these algorithms work and how we can, how you can go about implementing them.<br/>
好了 关于无监督学习问题 就讲这么多了 下一节课中我们 会涉及到更具体的学习算法 并开始讨论 这些算法是如何工作的 以及我们如何来实现它们 【教育无边界字幕组】翻译：碳老师 校对：linuxfish 审核：所罗门捷列夫</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Github高阶使用之webhook]]></title>
    <link href="http://blog.cxstars.com/14884651923136.html"/>
    <updated>2017-03-02T22:33:12+08:00</updated>
    <id>http://blog.cxstars.com/14884651923136.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">github webhook</h2>

<p>官网文档:<a href="https://developer.github.com/webhooks/">https://developer.github.com/webhooks/</a></p>

<h4 id="toc_1">tips</h4>

<ul>
<li>每个repo可以创建最多20个webhook</li>
<li>默认只订阅<code>push</code>事件</li>
<li><code>*</code>通配符事件不建议使用</li>
<li><code>Payloads</code>最大5M,不建议一次性<code>push</code>太多分支或者标签及备注</li>
</ul>

<h2 id="toc_2">Webhook Headers</h2>

<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X-GitHub-Event</code></td>
<td>The <a href="/v3/activity/events/types/">event type</a> that was triggered.</td>
</tr>
<tr>
<td><code>X-GitHub-Delivery</code></td>
<td>A <a href="http://en.wikipedia.org/wiki/Globally_unique_identifier">guid</a> to identify the payload and event being sent.</td>
</tr>
<tr>
<td><code>X-Hub-Signature</code></td>
<td>The value of this header is computed as the HMAC hex digest of the body, using the <code>secret</code> config option as the key.</td>
</tr>
</tbody>
</table>

<h2 id="toc_3">事件表</h2>

<span id="more"></span><!-- more -->

<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>Any time any event is triggered (<a href="#wildcard-event">Wildcard Event</a>).</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#commitcommentevent"><code>commit_comment</code></a></td>
<td>Any time a Commit is commented on.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#createevent"><code>create</code></a></td>
<td>Any time a Branch or Tag is created.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#deleteevent"><code>delete</code></a></td>
<td>Any time a Branch or Tag is deleted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#deploymentevent"><code>deployment</code></a></td>
<td>Any time a Repository has a new deployment created from the API.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#deploymentstatusevent"><code>deployment_status</code></a></td>
<td>Any time a deployment for a Repository has a status update from the API.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#forkevent"><code>fork</code></a></td>
<td>Any time a Repository is forked.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#gollumevent"><code>gollum</code></a></td>
<td>Any time a Wiki page is updated.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#issuecommentevent"><code>issue_comment</code></a></td>
<td>Any time a <a href="/v3/issues/comments/">comment on an issue</a> is created, edited, or deleted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#issuesevent"><code>issues</code></a></td>
<td>Any time an Issue is assigned, unassigned, labeled, unlabeled, opened, edited, milestoned, demilestoned, closed, or reopened.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#labelevent"><code>label</code></a></td>
<td>Any time a Label is created, edited, or deleted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#memberevent"><code>member</code></a></td>
<td>Any time a User is added or removed as a collaborator to a Repository, or has their permissions modified.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#membershipevent"><code>membership</code></a></td>
<td>Any time a User is added or removed from a team. <strong>Organization hooks only</strong>.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#milestoneevent"><code>milestone</code></a></td>
<td>Any time a Milestone is created, closed, opened, edited, or deleted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#organizationevent"><code>organization</code></a></td>
<td>Any time a user is added, removed, or invited to an Organization. <strong>Organization hooks only.</strong>
</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#orgblockevent"><code>org_block</code></a></td>
<td>Any time an organization blocks or unblocks a user. <strong>Organization hooks only</strong>.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#pagebuildevent"><code>page_build</code></a></td>
<td>Any time a Pages site is built or results in a failed build.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#projectcardevent"><code>project_card</code></a></td>
<td>Any time a Project Card is created, edited, moved, converted to an issue, or deleted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#projectcolumnevent"><code>project_column</code></a></td>
<td>Any time a Project Column is created, edited, moved, or deleted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#projectevent"><code>project</code></a></td>
<td>Any time a Project is created, edited, or deleted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#publicevent"><code>public</code></a></td>
<td>Any time a Repository changes from private to public.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#pullrequestreviewcommentevent"><code>pull_request_review_comment</code></a></td>
<td>Any time a <a href="/v3/pulls/comments">comment on a pull request's unified diff</a>  is created, edited, or deleted (in the Files Changed tab).</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#pullrequestreviewevent"><code>pull_request_review</code></a></td>
<td>Any time a pull request review is submitted.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#pullrequestevent"><code>pull_request</code></a></td>
<td>Any time a pull request is assigned, unassigned, labeled, unlabeled, opened, edited, closed, reopened, or synchronized (updated due to a new push in the branch that the pull request is tracking). Also any time a pull request review is requested, or a review request is removed.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#pushevent"><code>push</code></a></td>
<td>Any Git push to a Repository, including editing tags or branches. Commits via API actions that update references are also counted. <strong>This is the default event.</strong>
</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#repositoryevent"><code>repository</code></a></td>
<td>Any time a Repository is created, deleted (<a href="/v3/orgs/hooks/">organization hooks</a> only), made public, or made private.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#releaseevent"><code>release</code></a></td>
<td>Any time a Release is published in a Repository.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#statusevent"><code>status</code></a></td>
<td>Any time a Repository has a status update from the API</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#teamevent"><code>team</code></a></td>
<td>Any time a team is created, deleted, modified, or added to or removed from a repository. <strong>Organization hooks only</strong>
</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#teamaddevent"><code>team_add</code></a></td>
<td>Any time a team is added or modified on a Repository.</td>
</tr>
<tr>
<td><a href="/v3/activity/events/types/#watchevent"><code>watch</code></a></td>
<td>Any time a User stars a Repository.</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install a GitLab CE Omnibus package on Centos7]]></title>
    <link href="http://blog.cxstars.com/14884651028364.html"/>
    <updated>2017-03-02T22:31:42+08:00</updated>
    <id>http://blog.cxstars.com/14884651028364.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1. Install and configure the necessary dependencies</h2>

<pre><code class="language-shell">sudo yum install -y curl policycoreutils openssh-server openssh-clients
sudo systemctl enable sshd
sudo systemctl start sshd
sudo yum install postfix
sudo systemctl enable postfix
sudo systemctl start postfix
sudo systemctl start firewalld
sudo firewall-cmd --permanent --add-service=http
sudo systemctl reload firewalld
</code></pre>

<h2 id="toc_1">2. Add the GitLab package server and install the package</h2>

<pre><code class="language-shell">curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
sudo yum install -y gitlab-ce
</code></pre>

<h2 id="toc_2">3. Configure and start GitLab</h2>

<pre><code class="language-shell">sudo gitlab-ctl reconfigure


       *.                  *.
      ***                 ***
     *****               *****
    .******             *******
    ********            ********
   ,,,,,,,,,***********,,,,,,,,,
  ,,,,,,,,,,,*********,,,,,,,,,,,
  .,,,,,,,,,,,*******,,,,,,,,,,,,
      ,,,,,,,,,*****,,,,,,,,,.
         ,,,,,,,****,,,,,,
            .,,,***,,,,
                ,*,.

     _______ __  __          __
    / ____(_) /_/ /   ____ _/ /_
   / / __/ / __/ /   / __ `/ __ \
  / /_/ / / /_/ /___/ /_/ / /_/ /
  \____/_/\__/_____/\__,_/_.___/


gitlab: Thank you for installing GitLab!
gitlab: To configure and start GitLab, RUN THE FOLLOWING COMMAND:

sudo gitlab-ctl reconfigure

gitlab: GitLab should be reachable at http://localhost
gitlab: Otherwise configure GitLab for your system by editing /etc/gitlab/gitlab.rb file
gitlab: And running reconfigure again.
gitlab:
gitlab: For a comprehensive list of configuration options please see the Omnibus GitLab readme
gitlab: https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md
gitlab:

gitlab: GitLab now ships with a newer version of PostgreSQL (9.6.1), and will be used
gitlab: as the default in the next major release. To upgrade, RUN THE FOLLOWING COMMANDS:

sudo gitlab-ctl pg-upgrade

gitlab: For more details, please see:
gitlab: https://docs.gitlab.com/omnibus/settings/database.html#upgrade-packaged-postgresql-server
gitlab:
It looks like GitLab has not been configured yet; skipping the upgrade script.
</code></pre>

<h2 id="toc_3">4. Browse to the hostname and login</h2>

<pre><code class="language-shell">On your first visit, you&#39;ll be redirected to a password reset screen to provide the password for the initial administrator account. Enter your desired password and you&#39;ll be redirected back to the login screen.

The default account&#39;s username is root. Provide the password you created earlier and login. After login you can change the username if you wish.
</code></pre>

<h4 id="toc_4">添加安全转发端口</h4>

<p><code>iptables -A IN_public_allow -p tcp --dport 8080 -j ACCEPT</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP CI前的统一大杀器--vagrant]]></title>
    <link href="http://blog.cxstars.com/14882560898323.html"/>
    <updated>2017-02-28T12:28:09+08:00</updated>
    <id>http://blog.cxstars.com/14882560898323.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">vagrant</h2>

<p><em>官网</em> <a href="https://www.vagrantup.com">vagrant</a></p>

<blockquote>
<p>Vagrant is an open-source software product for building and maintaining portable virtual development environments. --wiki</p>
</blockquote>

<p><em>下载</em> <a href="https://www.vagrantup.com/downloads.html">Download</a></p>

<h4 id="toc_1">box cloud</h4>

<p><a href="https://atlas.hashicorp.com/boxes/search?utf8=%E2%9C%93&amp;sort=&amp;provider=&amp;q=">Discover Vagrant Boxes</a></p>

<h4 id="toc_2">基础命令</h4>

<p><em>添加镜像</em><br/>
<code>vagrant box add {title} {url}</code></p>

<p><em>在当前路径初始化镜像</em><br/>
<code>vagrant init {title}</code></p>

<pre><code class="language-shell">$ vagrant init centos6.7
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.
</code></pre>

<span id="more"></span><!-- more -->

<p><em>启动镜像</em><br/>
<code>vagrant up</code></p>

<pre><code class="language-shell">$ vagrant up
Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
==&gt; default: Importing base box &#39;centos6.7&#39;...
==&gt; default: Matching MAC address for NAT networking...
==&gt; default: Setting the name of the VM: php7_default_1488245774509_46459
==&gt; default: Clearing any previously set network interfaces...
==&gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==&gt; default: Forwarding ports...
    default: 22 (guest) =&gt; 2222 (host) (adapter 1)
==&gt; default: Booting VM...
==&gt; default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222
    default: SSH username: vagrant
    default: SSH auth method: private key
    default:
    default: Vagrant insecure key detected. Vagrant will automatically replace
    default: this with a newly generated keypair for better security.
    default:
    default: Inserting generated public key within guest...
    default: Removing insecure key from the guest if it&#39;s present...
    default: Key inserted! Disconnecting and reconnecting using new SSH key...
==&gt; default: Machine booted and ready!
==&gt; default: Checking for guest additions in VM...
==&gt; default: Mounting shared folders...
    default: /vagrant =&gt; /Users/star/php7
</code></pre>

<h4 id="toc_3">ssh镜像</h4>

<p><code>vagrant ssh</code></p>

<h4 id="toc_4">重启</h4>

<p><code>vagrant reload</code></p>

<h4 id="toc_5">provistion重启</h4>

<p><code>vagrant reload --provision</code></p>

<blockquote>
<p>which will quickly restart your virtual machine, skipping the initial import step</p>
</blockquote>

<h4 id="toc_6">暂停</h4>

<p><code>vagrant suspend</code></p>

<h4 id="toc_7">关机</h4>

<p><code>vagrant halt</code></p>

<h4 id="toc_8">删除</h4>

<p><code>vagrant destroy</code></p>

<h4 id="toc_9">启动器</h4>

<p><code>$ vagrant up --provider=vmware_fusion</code></p>

<h4 id="toc_10">share</h4>

<p><a href="https://www.vagrantup.com/docs/other/atlas.html">HashiCorp&#39;s Atlas</a><br/>
<code>vagrant login</code><br/>
<code>vagrant share</code></p>

<h4 id="toc_11">tips</h4>

<p><strong>慎用rm,如果在vagrant里使用rm -rf /,这样会将你的Vagrantfile文件及宿主机的共享目录删除</strong></p>

<h4 id="toc_12">Vagrantfile</h4>

<pre><code class="language-shell"># box版本
config.vm.box_version = &quot;1.0.0&quot;
config.vm.synced_folder &quot;宿主机目录&quot;,&quot;虚拟机目录&quot;
# 预加载文件
config.vm.provision :shell, path: &quot;bootstrap.sh&quot;
# 预加载行内
# config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL
#   apt-get update
#   apt-get install -y apache2
# SHELL
# 网络端口转发
config.vm.network :forwarded_port, guest: 80, host: 4567
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[phpcs集成git工作流]]></title>
    <link href="http://blog.cxstars.com/14879208825856.html"/>
    <updated>2017-02-24T15:21:22+08:00</updated>
    <id>http://blog.cxstars.com/14879208825856.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">git hook之pre-commit</h3>

<p><em>在提交代码前进行代码规范检查,因此使用git hook中的pre-commit,下面是pre-commit的概念</em></p>

<blockquote>
<p>这个钩子被 <strong>git commit</strong> 命令调用, 而且可以通过在命令中添加<strong>--no-verify</strong> 参数来跳过。这个钩子不需要参数，在得到提交消息和开始提交(commit)前被调用。<strong>如果钩子返回值不是0，那么 git commit 命令就会中止执行</strong>。</p>
</blockquote>

<h3 id="toc_1">pre-commit使用</h3>

<p><a href="https://github.com/star1989/phpcs_git"><em>github永久链接,后续改进更新</em></a></p>

<p><em>代码实现如下</em></p>

<pre><code class="language-shell">#!/bin/bash
#
# check PHP code syntax error and standard with phpcs
# author : star[github.com/star1989]
# date : 2017-02-24
PROJECT=$(git rev-parse --show-toplevel)
cd $PROJECT
SFILES=$(git diff --cached --name-only --diff-filter=ACMR HEAD | grep \\.php)
TMP_DIR=$PROJECT.&quot;/tmp&quot;

# Determine if a file list is passed
if [ &quot;$#&quot; -ne 0 ]
then
    exit 0
fi
echo &quot;Checking PHP Lint...&quot;
for FILE in $SFILES
do
#    echo &quot;php -l -d display_errors=0 ${FILE}&quot;
#   echo &quot;git show :$FILE &gt; $TMP_DIR/$FILE&quot;
    php -l -d display_errors=0 $FILE
    if [ $? != 0  ]
    then
        echo &quot;Fix the error before commit.&quot;
        exit 1
    fi
    FILES=&quot;$FILES $PROJECT/$FILE&quot;
done

if [ &quot;$FILES&quot; != &quot;&quot; ]
then
    echo &quot;Running Code Sniffer...&quot;

    TMP_DIR=/tmp/$(uuidgen)
    mkdir -p $TMP_DIR
    for FILE in $SFILES
    do
        mkdir -p $TMP_DIR/$(dirname $FILE)
        git show :$FILE &gt; $TMP_DIR/$FILE
    done
    phpcs --standard=PSR2 --encoding=utf-8 -n $TMP_DIR
    PHPCS_ERROR=$?
    rm -rf $TMP_DIR
    if [ $PHPCS_ERROR != 0 ]
    then
        echo &quot;Fix the error before commit.&quot;
        exit 1
    fi
fi

exit $?
</code></pre>

<h3 id="toc_2">效果</h3>

<pre><code class="language-shell">#正常情况
star@starMBP:~/Documents/web/query-word$ git commit -m &#39;test&#39;
Checking PHP Lint...
No syntax errors detected in public/index.php
No syntax errors detected in public/test.php
Running Code Sniffer...

FILE: ...rivate/tmp/A7518E0C-3C1A-4AB1-80BB-6C2B17F133E9/public/index.php
----------------------------------------------------------------------
FOUND 12 ERRORS AFFECTING 6 LINES
----------------------------------------------------------------------
  6 | ERROR | [ ] Constants must be uppercase; expected
    |       |     &#39;BASEROOTPATH&#39; but found &#39;BaseRootPath&#39;
  9 | ERROR | [x] Expected 1 space after IF keyword; 0 found
 16 | ERROR | [x] Expected 1 space after IF keyword; 0 found
 16 | ERROR | [x] Expected 1 space after closing parenthesis; found 0
 19 | ERROR | [x] Expected 1 space after closing brace; 0 found
 19 | ERROR | [x] Expected 1 space after ELSEIF keyword; 0 found
 19 | ERROR | [x] Expected 1 space after closing parenthesis; found 0
 21 | ERROR | [x] Expected 1 space after closing brace; 0 found
 21 | ERROR | [x] Expected 1 space after ELSEIF keyword; 0 found
 21 | ERROR | [x] Expected 1 space after closing parenthesis; found 0
 23 | ERROR | [x] Expected 1 space after closing brace; 0 found
 23 | ERROR | [x] Expected 1 space after ELSE keyword; 0 found
----------------------------------------------------------------------
PHPCBF CAN FIX THE 11 MARKED SNIFF VIOLATIONS AUTOMATICALLY
----------------------------------------------------------------------

Time: 73ms; Memory: 7.5Mb

Fix the error before commit.

#跳过情况
star@starMBP:~/Documents/web/query-word$ git commit --no-verify -m &#39;test&#39;
[master 3e68145] test
 2 files changed, 3 insertions(+)
 create mode 100644 public/test.php
</code></pre>

<h3 id="toc_3">后续</h3>

<p><em>既然可以跳过,那么就一定要在push时再行检查,所以就得后到git service的pre-receive hook</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHPer的高质量编码,代码规范自动检查工作具PHP_CodeSniffer]]></title>
    <link href="http://blog.cxstars.com/14879149134068.html"/>
    <updated>2017-02-24T13:41:53+08:00</updated>
    <id>http://blog.cxstars.com/14879149134068.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">对于技术和代码的思考</h2>

<p>最近看到一句话,触动颇深:</p>

<blockquote>
<p>行动上的勤勉不足以填补思想上的懒惰</p>
</blockquote>

<p>语言是面向对象的,技术是面向商业的.但这不是一个技术人员只会写代码的理由,遇到过很多面试人员往往3,5年编码经验,不过更多的感受是他们只用了3,5个月的经验过了3,5年.</p>

<p>所以并不是一直在做,就真的做好了.接下来的日子,希望自己能真正做好每一件事.</p>

<p>多人协作编码的前提是统一编码规范并执行.靠人去执行,靠人去检查,始终有限.技术改变生活,当然也包括技术人员的生活.</p>

<h2 id="toc_1">PHP_codeSniffer</h2>

<h4 id="toc_2">要求</h4>

<ul>
<li>PHP &gt;= 5.1.2</li>
<li>PHP &gt;= 5.2.4 (仅当使用SVN的pre-commit挂勾)</li>
</ul>

<h4 id="toc_3">安装</h4>

<p><em>shell install</em></p>

<pre><code class="language-shell">curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcs.phar
php phpcs.phar -h

curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcbf.phar
php phpcbf.phar -h
</code></pre>

<p><em>pear install</em></p>

<pre><code class="language-shell">pear install PHP_CodeSniffer
</code></pre>

<p><em>composer install</em></p>

<pre><code class="language-shell">command方式
composer global require &quot;squizlabs/php_codesniffer=*&quot;

compser.json方式
{
    &quot;require-dev&quot;: {
        &quot;squizlabs/php_codesniffer&quot;: &quot;2.*&quot;
    }
}
</code></pre>

<span id="more"></span><!-- more -->

<h4 id="toc_4">phpcs使用</h4>

<p><em>phpcs的所有参数和说明</em></p>

<pre><code class="language-shell">star@starMBP:~$ phpcs -h
Usage: phpcs [-nwlsaepqvi] [-d key[=value]] [--colors] [--no-colors] [--stdin-path=&lt;stdinPath&gt;]
    [--report=&lt;report&gt;] [--report-file=&lt;reportFile&gt;] [--report-&lt;report&gt;=&lt;reportFile&gt;] ...
    [--report-width=&lt;reportWidth&gt;] [--generator=&lt;generator&gt;] [--tab-width=&lt;tabWidth&gt;]
    [--severity=&lt;severity&gt;] [--error-severity=&lt;severity&gt;] [--warning-severity=&lt;severity&gt;]
    [--runtime-set key value] [--config-set key value] [--config-delete key] [--config-show]
    [--standard=&lt;standard&gt;] [--sniffs=&lt;sniffs&gt;] [--exclude=&lt;sniffs&gt;] [--encoding=&lt;encoding&gt;]
    [--extensions=&lt;extensions&gt;] [--ignore=&lt;patterns&gt;] [--bootstrap=&lt;bootstrap&gt;]
    [--file-list=&lt;fileList&gt;] &lt;file&gt; ...
                      Set runtime value (see --config-set)
        -n            Do not print warnings (shortcut for --warning-severity=0)
        -w            Print both warnings and errors (this is the default)
        -l            Local directory only, no recursion
        -s            Show sniff codes in all reports
        -a            Run interactively
        -e            Explain a standard by showing the sniffs it includes
        -p            Show progress of the run
        -q            Quiet mode; disables progress and verbose output
        -v[v][v]      Print verbose output
        -i            Show a list of installed coding standards
        -d            Set the [key] php.ini value to [value] or [true] if value is omitted
        --help        Print this help message
        --version     Print version information
        --colors      Use colors in output
        --no-colors   Do not use colors in output (this is the default)
        &lt;file&gt;        One or more files and/or directories to check
        &lt;fileList&gt;    A file containing a list of files and/or directories to check (one per line)
        &lt;stdinPath&gt;   If processing STDIN, the file path that STDIN will be processed as
        &lt;bootstrap&gt;   A comma separated list of files to run before processing starts
        &lt;encoding&gt;    The encoding of the files being checked (default is iso-8859-1)
        &lt;extensions&gt;  A comma separated list of file extensions to check
                      (extension filtering only valid when checking a directory)
                      The type of the file can be specified using: ext/type
                      e.g., module/php,es/js
        &lt;generator&gt;   Uses either the &quot;HTML&quot;, &quot;Markdown&quot; or &quot;Text&quot; generator
                      (forces documentation generation instead of checking)
        &lt;patterns&gt;    A comma separated list of patterns to ignore files and directories
        &lt;report&gt;      Print either the &quot;full&quot;, &quot;xml&quot;, &quot;checkstyle&quot;, &quot;csv&quot;
                      &quot;json&quot;, &quot;emacs&quot;, &quot;source&quot;, &quot;summary&quot;, &quot;diff&quot;, &quot;junit&quot;
                      &quot;svnblame&quot;, &quot;gitblame&quot;, &quot;hgblame&quot; or &quot;notifysend&quot; report
                      (the &quot;full&quot; report is printed by default)
        &lt;reportFile&gt;  Write the report to the specified file path
        &lt;reportWidth&gt; How many columns wide screen reports should be printed
                      or set to &quot;auto&quot; to use current screen width, where supported
        &lt;sniffs&gt;      A comma separated list of sniff codes to include or exclude during checking
                      (all sniffs must be part of the specified standard)
        &lt;severity&gt;    The minimum severity required to display an error or warning
        &lt;standard&gt;    The name or path of the coding standard to use
        &lt;tabWidth&gt;    The number of spaces each tab represents
</code></pre>

<p><em>查看当前标准</em></p>

<pre><code class="language-shell">star@starMBP:~$ phpcs -i
The installed coding standards are MySource, PEAR, PHPCS, PSR1, PSR2, Squiz and Zend
</code></pre>

<p><em>忽略warning(如一行超过85个字符会报warning,不强制,建议关掉)</em></p>

<pre><code class="language-shell">#参数命令
phpcs -n your_file
#环境命令
phpcs --config-set show_warnings 0
</code></pre>

<p><em>设置默认标准</em></p>

<blockquote>
<p>By default, PHP_CodeSniffer will use the PEAR coding standard if no standard is supplied on the command line. </p>
</blockquote>

<pre><code class="language-shell">star@starMBP:~$ phpcs --config-set default_standard PSR2
Config value &quot;default_standard&quot; added successfully
</code></pre>

<p><em>设置终端颜色输出</em></p>

<pre><code>phpcs --config-set colors 1
</code></pre>

<p><em>设置文件编码标准</em></p>

<blockquote>
<p>By default, PHP_CodeSniffer will treat all source files as if they use ISO-8859-1 encoding. This can cause double-encoding problems when generating UTF-8 encoded XML reports</p>
</blockquote>

<pre><code class="language-shell">phpcs --config-set encoding utf-8
</code></pre>

<p><em>加载自定义编码</em></p>

<pre><code class="language-shell">phpcs --config-set installed_paths your_standard_path
</code></pre>

<p><em>检查PHP文件</em></p>

<pre><code class="language-shell">star@starMBP:~$ phpcs sample.php
FOUND 43 ERRORS AFFECTING 33 LINES
----------------------------------------------------------------------
   3 | ERROR | [ ] Each class must be in a namespace of at least one
     |       |     level (a top-level vendor name)
   3 | ERROR | [x] Opening brace of a class must be on the line after
     |       |     the definition
   5 | ERROR | [x] Opening brace should be on a new line
  23 | ERROR | [x] Expected 1 space after IF keyword; 0 found
  ........
----------------------------------------------------------------------
PHPCBF CAN FIX THE 42 MARKED SNIFF VIOLATIONS AUTOMATICALLY
----------------------------------------------------------------------

Time: 633ms; Memory: 22.75Mb
</code></pre>

<p><strong>在这里其实已经提到了下一步要做什么了,使用PHPCBF修复</strong></p>

<p><em>phpcbf修复</em></p>

<pre><code class="language-shell">star@starMBP:~$ phpcbf --standard=PSR2 sample.php
Changing into directory /Users/star/sample.php
Processing sample.php [PHP =&gt; 4751 tokens in 449 lines]... DONE in 555ms (42 fixable violations)
        =&gt; Fixing file: 0/42 violations remaining [made 3 passes]... DONE in 1.98 secs
Patched 1 file
Time: 2.65 secs; Memory: 36.5Mb
</code></pre>

<h4 id="toc_5">参考</h4>

<p><a href="https://github.com/squizlabs/PHP_CodeSniffer/wiki">CodeSniffer_wiki</a><br/>
<a href="https://pear.php.net/manual/en/package.php.php-codesniffer.coding-standard-tutorial.php">Coding Standard Tutorial</a></p>

<h2 id="toc_6">后续</h2>

<p>继续思考,怎样更高效更加符合技术流程.</p>

<p>后续使用git的做提交前的代码格式化,并使用jenkins做持续集成.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[intl,geoip,mongodb扩展macos安装踩坑]]></title>
    <link href="http://blog.cxstars.com/14878474870577.html"/>
    <updated>2017-02-23T18:58:07+08:00</updated>
    <id>http://blog.cxstars.com/14878474870577.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">扩展组件</h2>

<ul>
<li><a href="http://pecl.php.net/package/geoip">geoip</a></li>
<li>intl</li>
<li><a href="http://pecl.php.net/package/imagick">imagick</a></li>
<li><a href="http://php.net/manual/zh/mongodb.installation.manual.php">mongodb</a></li>
</ul>

<h2 id="toc_1">intl</h2>

<h4 id="toc_2">错误</h4>

<pre><code class="language-shell">configure: error: Unable to detect ICU prefix or no failed. Please verify ICU install prefix and make sure icu-config works.
</code></pre>

<p><strong>解决</strong></p>

<pre><code class="language-shell">brew install --force icu4c
pecl install intl
输入icu4c路径:/usr/local/opt/icu4c

Build process completed successfully
Installing &#39;/usr/local/php/lib/php/extensions/debug-zts-20131226/intl.so&#39;
install ok: channel://pecl.php.net/intl-3.0.0
configuration option &quot;php_ini&quot; is not set to php.ini location
You should add &quot;extension=intl.so&quot; to php.ini
</code></pre>

<h2 id="toc_3">geoIP</h2>

<h4 id="toc_4">错误</h4>

<pre><code class="language-shell">checking for geoip files in default path... not found
configure: error: Please reinstall the geoip distribution
</code></pre>

<p><strong>解决</strong></p>

<pre><code class="language-shell">curl -O http://www.maxmind.com/download/geoip/api/c/GeoIP-latest.tar.gz
tar -zxf GeoIP-latest.tar.gz
cd GeoIP-1.6.0/
./configure --prefix=/Users/star/Documents/geo
make &amp;&amp; make install

cd ../geoip-1.0.8
phpize
vim configure
在4102行添加上面的库PATH
 4101   # --with-geoip -&gt; check with-path
 4102   SEARCH_PATH=&quot;/usr/local /usr /sw /opt/local /Users/star/Documents/geo&quot;
 4103   SEARCH_FOR=&quot;/include/GeoIP.h&quot;
 4104   if test -r $PHP_GEOIP/$SEARCH_FOR; then
 4105     GEOIP_DIR=$PHP_GEOIP
 4106   else # search default path list
 4107     { $as_echo &quot;$as_me:${as_lineno-$LINENO}: checking for geoip files in default path&quot; &gt;&amp;5
 4108 $as_echo_n &quot;checking for geoip files in default path... &quot; &gt;&amp;6; }
 4109     for i in $SEARCH_PATH ; do
 4110       if test -r $i/$SEARCH_FOR; then
 4111         GEOIP_DIR=$i
 4112         { $as_echo &quot;$as_me:${as_lineno-$LINENO}: result: found in $i&quot; &gt;&amp;5
 4113 $as_echo &quot;found in $i&quot; &gt;&amp;6; }
 4114       fi
 4115     done
 4116   fi
 ./configure --with-php-config=/usr/local/php/bin/php-config
 make
 make install
</code></pre>

<h4 id="toc_5">错误</h4>

<p><code>GeoIPCity.dat Not Found</code></p>

<p><strong>解决</strong></p>

<pre><code class="language-shell">curl -O http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz
gunzip GeoLiteCity.dat.gz
mv GeoLiteCity.dat /Users/star/Documents/geo/share/GeoIP/
</code></pre>

<h2 id="toc_6">mongoDB</h2>

<h4 id="toc_7">错误</h4>

<p><code>make时错误 openssl头文件找不到</code></p>

<p><strong>解决</strong></p>

<pre><code class="language-shell">ln -s /usr/local/opt/openssl/include/openssl /usr/local/include/
</code></pre>

<h2 id="toc_8">imagick</h2>

<p><code>pecl install imagick</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP扩展基础知识及生成]]></title>
    <link href="http://blog.cxstars.com/14873400340656.html"/>
    <updated>2017-02-17T22:00:34+08:00</updated>
    <id>http://blog.cxstars.com/14873400340656.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">扩展知识</h2>

<h3 id="toc_1">PHP架构图</h3>

<p><img src="http://bimg.cxstars.com/2017-02-15-14871384652088.jpg" alt="PHP架构图"/></p>

<h3 id="toc_2">PHP框架生成器</h3>

<pre><code class="language-shell">star@starMBP:~/Documents/images/php/php-5.6.22/ext$ ls
ext_skel
ext_skel_win32.php
</code></pre>

<p><strong>生成器使用方法</strong></p>

<pre><code class="language-shell">./ext_skel --extname=module [--proto=file] [--stubs=file] [--xml[=file]]
           [--skel=dir] [--full-xml] [--no-help]

  --extname=module   module is the name of your extension
  --proto=file       file contains prototypes of functions to create
  --stubs=file       generate only function stubs in file
  --xml              generate xml documentation to be added to phpdoc-svn
  --skel=dir         path to the skeleton directory
  --full-xml         generate xml documentation for a self-contained extension
                     (not yet implemented)
  --no-help          don&#39;t try to be nice and create comments in the code
                     and helper functions to test if the module compiled
</code></pre>

<h3 id="toc_3">框架文件结构</h3>

<pre><code class="language-shell">star@starMBP:~/Documents/images/php/php-5.6.22/ext$ ls star_test/
CREDITS         config.m4       php_star_test.h star_test.php
EXPERIMENTAL    config.w32      star_test.c     tests
</code></pre>

<h4 id="toc_4">config.m4</h4>

<blockquote>
<p><em>config.m4</em> 文件告诉 UNIX 构建系统哪些扩展 configure 选项是支持的，你需要哪些扩展库，以及哪些源文件要编译成它的一部分。</p>

<p><em>config.m4</em> 文件使用 <strong>GNU autoconf</strong> 语法编写。简而言之，就是用强大的宏语言增强的 shell 脚本。注释用字符串 <strong>dnl</strong> 分隔，字符串则放在左右方括号中间（例如，[ 和 ]）。字符串可按需要多次嵌套引用。</p>
</blockquote>

<h4 id="toc_5">PHP_ARG_*: 赋予用户可选项</h4>

<blockquote>
<p><strong>PHP_ARG_WITH()</strong> 用于取得参数的选项，例如扩展所需库或程序的位置<br/>
<strong>PHP_ARG_ENABLE()</strong> 用于代表简单标志的选项。</p>
</blockquote>

<pre><code class="language-shell">$ ./configure --with-example=/some/library/path/example-config --disable-example-debug --with-example-extra=/another/library/path
...
checking for example support... yes
checking whether to enable debugging support in example... no
checking for extra libraries for example... /another/library/path
...

PHP_ARG_WITH(example, for example support,
[  --with-example[=FILE]       Include example support. File is the optional path to example-config])
PHP_ARG_ENABLE(example-debug, whether to enable debugging support in example,
[  --enable-example-debug        example: Enable debugging support in example], no, no)
PHP_ARG_WITH(example-extra, for extra libraries for example,
[  --with-example-extra=DIR      example: Location of extra libraries for example], no, no)

dnl 检测扩展是否已启用
if test &quot;$PHP_EXAMPLE&quot; != &quot;no&quot;; then
  
  dnl 检测 example-config。首先尝试所给出的路径，然后在 $PATH 中寻找
  AC_MSG_CHECKING([for example-config])
  EXAMPLE_CONFIG=&quot;example-config&quot;
  if test &quot;$PHP_EXAMPLE&quot; != &quot;yes&quot;; then
    EXAMPLE_PATH=$PHP_EXAMPLE
  else
    EXAMPLE_PATH=`$php_shtool path $EXAMPLE_CONFIG`
  fi
  
  dnl 如果找到可用的 example-config，就使用它
  if test -f &quot;$EXAMPLE_PATH&quot; &amp;&amp; test -x &quot;$EXAMPLE_PATH&quot; &amp;&amp; $EXAMPLE_PATH --version &gt; /dev/null 2&gt;&amp;1; then
    AC_MSG_RESULT([$EXAMPLE_PATH])
    EXAMPLE_LIB_NAME=`$EXAMPLE_PATH --libname`
    EXAMPLE_INCDIRS=`$EXAMPLE_PATH --incdirs`
    EXAMPLE_LIBS=`$EXAMPLE_PATH --libs`
    
    dnl 检测扩展库是否工作正常
    PHP_CHECK_LIBRARY($EXAMPLE_LIB_NAME, example_critical_function,
    [
      dnl 添加所需的 include 目录
      PHP_EVAL_INCLINE($EXAMPLE_INCDIRS)
      dnl 添加所需的扩展库及扩展库所在目录
      PHP_EVAL_LIBLINE($EXAMPLE_LIBS, EXAMPLE_SHARED_LIBADD)
    ],[
      dnl 跳出
      AC_MSG_ERROR([example library not found. Check config.log for more information.])
    ],[$EXAMPLE_LIBS]
    )
  else
    dnl 没有可用的 example-config，跳出
    AC_MSG_RESULT([not found])
    AC_MSG_ERROR([Please check your example installation.])
  fi
  
  dnl 检测是否启用调试
  if test &quot;$PHP_EXAMPLE_DEBUG&quot; != &quot;no&quot;; then
    dnl 是，则设置 C 语言宏指令
    AC_DEFINE(USE_EXAMPLE_DEBUG,1,[Include debugging support in example])
  fi
  
  dnl 检测额外的支持
  if test &quot;$PHP_EXAMPLE_EXTRA&quot; != &quot;no&quot;; then
    if test &quot;$PHP_EXAMPLE_EXTRA&quot; == &quot;yes&quot;; then
      AC_MSG_ERROR([You must specify a path when using --with-example-extra])
    fi
    
    PHP_CHECK_LIBRARY(example-extra, example_critical_extra_function,
    [
      dnl 添加所需路径
      PHP_ADD_INCLUDE($PHP_EXAMPLE_EXTRA/include)
      PHP_ADD_LIBRARY_WITH_PATH(example-extra, $PHP_EXAMPLE_EXTRA/lib, EXAMPLE_SHARED_LIBADD)
      AC_DEFINE(HAVE_EXAMPLEEXTRALIB,1,[Whether example-extra support is present and requested])
      EXAMPLE_SOURCES=&quot;$EXAMPLE_SOURCES example_extra.c&quot;
    ],[
      AC_MSG_ERROR([example-extra lib not found. See config.log for more information.])
    ],[-L$PHP_EXAMPLE_EXTRA/lib]
    )
  fi
  
  dnl 最后，将扩展及其所需文件等信息传给构建系统
  PHP_NEW_EXTENSION(example, example.c $EXAMPLE_SOURCES, $ext_shared)
  PHP_SUBST(EXAMPLE_SHARED_LIBADD)
fi
</code></pre>

<h2 id="toc_6">生成扩展</h2>

<pre><code class="language-shell">star@starMBP:~/Documents/images/php/php-5.6.22/ext$ ./ext_skel --extname=star_queue
Creating directory star_queue
Creating basic files: config.m4 config.w32 .gitignore star_queue.c php_star_queue.h CREDITS EXPERIMENTAL tests/001.phpt star_queue.php [done].

To use your new extension, you will have to execute the following steps:

1.  $ cd ..
2.  $ vi ext/star_queue/config.m4
3.  $ ./buildconf
4.  $ ./configure --[with|enable]-star_queue
5.  $ make
6.  $ ./sapi/cli/php -f ext/star_queue/star_queue.php
7.  $ vi ext/star_queue/star_queue.c
8.  $ make

Repeat steps 3-6 until you are satisfied with ext/star_queue/config.m4 and
step 6 confirms that your module is compiled into PHP. Then, start writing
code and repeat the last two steps as often as necessary.
</code></pre>

<h2 id="toc_7">修改config.m4</h2>

<pre><code class="language-c"> 16 PHP_ARG_ENABLE(star_queue, whether to enable star_queue support,
 17 Make sure that the comment is aligned:
 18 [  --enable-star_queue           Enable star_queue support])
</code></pre>

<h2 id="toc_8">编译</h2>

<pre><code class="language-shell">phpize
./configure --with-php-config=/your php-config path
make
make install
</code></pre>

<p>查看扩展<br/>
<code>ls /usr/local/php/lib/php/extensions/debug-zts-20131226/</code></p>

<pre><code class="language-shell">star_queue.so
</code></pre>

<h2 id="toc_9">测试扩展</h2>

<p><code>php -f star_queue.php</code></p>

<pre><code class="language-shell">star@starMBP:~/Documents/images/php/php-5.6.22/ext/star_queue$ php -f star_queue.php
Functions available in the test extension:
queue_new
queue_push
queue_pop
queue_count
confirm_star_queue_compiled

Congratulations! You have successfully modified ext/star_queue/config.m4. Module star_queue is now compiled into PHP.
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机编码与python编码]]></title>
    <link href="http://blog.cxstars.com/14850124799483.html"/>
    <updated>2017-01-21T23:27:59+08:00</updated>
    <id>http://blog.cxstars.com/14850124799483.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">编码</h2>

<h3 id="toc_1">ASCII</h3>

<blockquote>
<p>计算机发明时,美国人只考虑了英语,所以当时的ASCII编码只有8个比特,即1个字节.大小英文字母/数字/标点符号/特殊符号等127个字母被纳入并规范成了ASCII编码.</p>
</blockquote>

<h3 id="toc_2">Unicode(Universal Multiple-Octet Coded Character Set)</h3>

<blockquote>
<p>ASCII编码只适用于英语国家,所以后来百家争鸣,中国有<strong>GB2312</strong>编码,韩国/日本等也都自制编码.就这样,冲突来了.<br/>
为了解决冲突,Unicode编码被协商制定出来.将世界上所有语言字符都编码成一个数字.<br/>
Unicode字符码是32位，4个字节。</p>
</blockquote>

<h3 id="toc_3">UTF-8</h3>

<blockquote>
<p>Unicode编码虽然兼容ASCII,但是会产生极大的浪费,Double了.所以才出现了把Unicode编码转化为<em>可变长编码</em>的UTF-8编码.UTF-8编码氢一个Unicode字符根据不同的数字大小编码成1-6个字节.英文字母1个字节,汉字通常3字节,生僻字4-6字节.<br/>
一般情况均传输的是英文字母(都是代码).</p>
</blockquote>

<h2 id="toc_4">计算机内存编码</h2>

<blockquote>
<p>早期Unicode编码就是16位2字节定长.但是中国文化5千年,文字太多,居然超过了65536个.So,Unicode就从定长走向了不定长的道路.<br/>
计算机处理文本的时候，内存中一般都不用UTF-8。因为UTF-8是变长编码，不从头扫描一遍，你不知道第几个字符在哪个位置上，这在处理的时候非常浪费时间。现在很多语言/程序的处理办法，是使用源于原始UTF-16的一个定长编码，只处理字符码在16位以内的字符，不支持超过16位的罕见字。这种16位定长的编码方式被称为UCS-2。那些零星的几个突破16位的字符，除非你专门研究古文或者奇怪的小语种，一般来说是遇不到的。遇到了也是黑人问号脸。<br/>
解决办法:不怕浪费空间的，就用UTF-32，不怕浪费处理时间的，就用完整的UTF-16，或者索性用UTF-8。</p>
</blockquote>

<h2 id="toc_5">python编码</h2>

<p>在python2中,<code>&#39;xxx&#39;</code>和<code>u&#39;xxx&#39;</code>是完全不一样的.前者是UTF-8编码的,也同ASCII编码,后者是Unicode编码.<br/>
Unicode转UTF-8编码:<br/>
<code>u&#39;aaa&#39;.encode(&#39;utf-8&#39;)</code><br/>
UTF-8转Unicode编码:<br/>
<code>&#39;中国&#39;.decode(&#39;utf-8&#39;)</code><br/>
输入中文编码前提:<br/>
<code># -*- coding: utf-8 -*-</code></p>

<p>在python3中,<code>&#39;xxx&#39;</code>和<code>u&#39;xxx&#39;</code>都是Unicode编码.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用python搭建ss梯子]]></title>
    <link href="http://blog.cxstars.com/14848778197605.html"/>
    <updated>2017-01-20T10:03:39+08:00</updated>
    <id>http://blog.cxstars.com/14848778197605.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">CentOS7</h2>

<pre><code class="language-sh">yum install python-setuptools &amp;&amp; easy_install pip
pip install shadowsocks
</code></pre>

<h2 id="toc_1">启动命令</h2>

<pre><code class="language-sh">ssserver -p 8836 -k `password` -m rc4-md5
#或者可以通过以下指令在后台启动shadowsocks的服务：
ssserver -p 8836 -k `password` -m rc4-md5 -d start
ssserver -p 8836 -k `password` -m rc4-md5 -d stop
</code></pre>

<p><strong>优化版本</strong><br/>
* 创建/etc/shadownsocks.json配置文件<br/>
* 写入配置:</p>

<pre><code class="language-sh">{
    &quot;server&quot;:&quot;你的服务器ip地址&quot;,
    &quot;server_port&quot;:10088,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;你设置的密码&quot;,
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;fast_open&quot;: false
}
</code></pre>

<p>优化后的启动命令:</p>

<pre><code class="language-sh">ssserver -c /etc/shadowsocks.json
#或者在后台运行
ssserver -c /etc/shadowsocks.json -d start
ssserver -c /etc/shadowsocks.json -d stop
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[金山翻译&时间的workflow]]></title>
    <link href="http://blog.cxstars.com/14848776957351.html"/>
    <updated>2017-01-20T10:01:35+08:00</updated>
    <id>http://blog.cxstars.com/14848776957351.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">项目链接</h2>

<p><a href="https://github.com/star1989/star_workflow">https://github.com/star1989/star_workflow</a></p>

<h2 id="toc_1">金山翻译</h2>

<h3 id="toc_2"><strong>功能:</strong></h3>

<ul>
<li>中英文翻译</li>
<li>音标</li>
<li>发音(<strong><em>默认美式</em></strong>)</li>
<li>复制(当前选中行文本,内容分为:音标,释意几行展示,可以自由复制)

<ul>
<li>注:复制的同时都会有读音</li>
<li>复制示例:<code>am:[stɑr] ,en:[stɑ:(r)]</code></li>
</ul></li>
<li>添加单词HOOK</li>
</ul>

<h3 id="toc_3">按键</h3>

<p><em>dc</em></p>

<blockquote>
<p>对应中文的单词,而且也离左手近,比较方便(主要是懒)</p>
</blockquote>

<h3 id="toc_4">效果</h3>

<ul>
<li><p>英文翻译<br/>
<img src="http://bimg.cxstars.com/2017-01-20-14848765913701.jpg" alt="英文翻译截图"/></p></li>
<li><p>中文翻译<br/>
<img src="http://bimg.cxstars.com/2017-01-21-14850042653066.jpg" alt="中文翻译截图"/></p></li>
<li><p>添加单词HOOK<br/>
<img src="http://bimg.cxstars.com/2017-01-25-14853523310481.jpg" alt="添加单词HOOK图"/></p></li>
<li><p>添加单词通知<br/>
<img src="http://bimg.cxstars.com/2017-01-25-14853524781043.jpg" alt="添加单词通知"/></p></li>
</ul>

<h3 id="toc_5">金山API</h3>

<p>项目里我已经放上我自己的API KEY,方便跟我一样懒的道友们.<br/>
不过也建议大家自行申请,非常方便.<a href="http://open.iciba.com/?c=api">金山词霸API</a><br/>
修改文件<code>jsfy.py</code>:<br/>
<code>app_key = &quot;put your api key&quot;</code></p>

<h2 id="toc_6">time</h2>

<h3 id="toc_7">显示时间相关的信息:日期,时间,周几,今天是一年中的多少天,本周是一年中的多少周</h3>

<h3 id="toc_8">按键</h3>

<p><em>now</em></p>

<blockquote>
<p>为了节约mac上状态的位置,而且可以通过workflow快速的复制当天的时间信息,方便我懒得输TODO里的日期之类的.同时也提醒自己时间飞快,惜时务事.</p>
</blockquote>

<h3 id="toc_9">效果</h3>

<p><img src="http://bimg.cxstars.com/2017-02-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-01%2020.57.39.png" alt="now截图"/></p>

<h2 id="toc_10">参考资料</h2>

<ul>
<li><a href="http://www.deanishe.net/alfred-workflow/">Alfred-Workflow Python</a></li>
<li><a href="https://www.alfredapp.com/help/workflows/">Alfred office help</a></li>
</ul>

<h2 id="toc_11">ToDoList</h2>

<ul>
<li>金山翻译

<ul>
<li><del>添加单词到单词本(v1.3:2017-01-25)</del></li>
<li><del>中翻英(v1.1:2017-01-21)</del></li>
<li><del>单词顺序列表/当天应记单词列表API(2017-02-01)</del></li>
<li>安卓单词APP</li>
<li>每日一句</li>
</ul></li>
<li>time

<ul>
<li>历史上的今天</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python语法总结]]></title>
    <link href="http://blog.cxstars.com/14842902733244.html"/>
    <updated>2017-01-13T14:51:13+08:00</updated>
    <id>http://blog.cxstars.com/14842902733244.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">变量</h2>

<h3 id="toc_1">命令规则</h3>

<ul>
<li>必须是大小写英文,数字和_的组合,且不能用数字开头</li>
<li>不用声明,直接使用(同PHP)</li>
</ul>

<h3 id="toc_2">类型</h3>

<ul>
<li>整数</li>
<li>浮点</li>
<li>字符串</li>
<li>布尔</li>
<li>空: None (与0不同)</li>
<li>Tuple : 元组,值不可变更</li>
<li>List : 表,值可以变更[下限:上限:步长]</li>
<li>Dictionary : 字典</li>
<li>自定义数据类型</li>
</ul>

<h2 id="toc_3">语法</h2>

<h3 id="toc_4">缩进</h3>

<p>python强制使用缩进来解析块代码.</p>

<h3 id="toc_5">运算符</h3>

<ul>
<li>数学 : <code>+,-,*,/,**,%</code></li>
<li>判断 : <code>==,!=,&gt;,&gt;=,&lt;,&lt;=,in</code></li>
<li>逻辑 : <code>and,or,not</code></li>
</ul>

<h3 id="toc_6">条件语句</h3>

<pre><code class="language-python">if condition1:
    do1
elif condition2:
    do2
elif condition3:
    do3
else:
    do4
</code></pre>

<h3 id="toc_7">循环</h3>

<p><strong>for</strong></p>

<pre><code class="language-python">for elemnt in list:
    statment
</code></pre>

<p><strong>while</strong></p>

<pre><code class="language-python">while condition:
    statement
</code></pre>

<p><strong>continue</strong><br/>
<strong>break</strong></p>

<span id="more"></span><!-- more -->

<h3 id="toc_8">错误处理</h3>

<ul>
<li>函数返回值</li>
<li>异常处理</li>
</ul>

<pre><code class="language-python">try:
    do1
except exception1:
    do e1==只有exception1才会进入这里==
except exception2:
    do e2
except:
    do default e==默认的exception处理==
else:
    do elsedo==如果没有exception则进入这里==
finally:
    do finallydo==不论有没有发生exception都要执行==
</code></pre>

<h2 id="toc_9">函数</h2>

<h3 id="toc_10">定义函数</h3>

<p><strong>实现功能,重复利用</strong></p>

<pre><code class="language-python">def func_name(a,b,...):
    statement
    return v1,v2,...
</code></pre>

<p><strong>若没有return或者return后无返回值时,函数将自动返回None</strong></p>

<h3 id="toc_11">参数传递</h3>

<ul>
<li>按顺序传递</li>
<li>关键字传递</li>
<li>参数默认值</li>
<li>包裹传递(packing) &amp; 解包裹(unpacking)</li>
</ul>

<p><strong>可混用,混用原则:</strong><em>先位置,后关键字,包裹位置,包裹关键字</em></p>

<h4 id="toc_12">packing</h4>

<pre><code class="language-python">&gt;&gt;&gt; def pack(*param):
...     print param
&gt;&gt;&gt; pack(1,2,3,4,&quot;abc&quot;)
(1, 2, 3, 4, &#39;abc&#39;)
</code></pre>

<p>平常应用,可以强制将tuple转换成list:</p>

<pre><code class="language-python">&gt;&gt;&gt; def pack2(*param):
...     param = list(param)
...     param[0] = &quot;Hello&quot;
...     param[1] = &quot;Python&quot;
...     print param
&gt;&gt;&gt; pack2(1,2,&quot;end&quot;)
[&#39;Hello&#39;, &#39;Python&#39;, &#39;end&#39;]
</code></pre>

<h4 id="toc_13">unpacking</h4>

<p><code>**param</code></p>

<h3 id="toc_14">函数对象(lambda)</h3>

<blockquote>
<p>这种能够接受一个函数作为参数的函数叫做「高阶函数」（higher-order function），是来自函数式编程（functional programming）的思想。</p>
</blockquote>

<pre><code class="language-python">&gt;&gt;&gt; seq=[1,2,3,4,5]
&gt;&gt;&gt; map(lambda x:x**3, [ x for x in seq ])
[1, 8, 27, 64, 125]
</code></pre>

<p><strong>高阶函数</strong>:<br/>
* filter(function, sequence)：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回<br/>
* map(function, sequence) ：对sequence中的item依次执行function(item)，见执行结果组成一个List返回<br/>
* reduce(function, sequence, starting_value)：对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和<br/>
* lambda：这是Python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似与C语言中的宏，这些叫做lambda的函数，是从LISP借用来的，可以用在任何需要函数的地方</p>

<p><strong>lambda与def的差别</strong></p>

<pre><code class="language-python">map( lambda x: x*x, [y for y in range(10)] )
</code></pre>

<pre><code class="language-python">def sq(x):
    return x * x
map(sq, [y for y in range(10)])
</code></pre>

<h2 id="toc_15">面向对象的类</h2>

<h3 id="toc_16">定义</h3>

<p><strong>使用class关键字定义一个类,并且类名首字母大写.</strong></p>

<h3 id="toc_17">语法</h3>

<pre><code class="language-python">class PyClass:
variables
functions
</code></pre>

<h3 id="toc_18">创建对象</h3>

<p><code>myClass = PyClass()</code></p>

<h3 id="toc_19">引用对象属性</h3>

<p><code>myClass.attribute</code></p>

<h3 id="toc_20">作用域</h3>

<ul>
<li>通过self调用类属性</li>
<li>对象生成时自动执行的特殊方法: <code>__init__()</code></li>
<li>类的属性是对数据的封装,方法则是对类的行为封装</li>
<li>类属性:

<ol>
<li>公有属性.</li>
<li>内置属性:由系统在定义类的时候默认添加,由前后两个下划线构成<code>__dict__</code>,<code>__module__</code></li>
<li>私有属性:不能被类以外的函数调用.定义时在属性名前加<code>__</code> </li>
</ol></li>
<li>方法也分为<strong>公有方法</strong>和<strong>私有方法</strong>

<ol>
<li>私有方法:以<code>__</code>定义</li>
<li>类方法:被<code>classmethod()</code>函数处理过的函数,添加类装饰器<code>@classmethod</code></li>
<li>静态方法:等于&quot;全局函数&quot;</li>
</ol></li>
</ul>

<pre><code class="language-python">from functools import wraps

class A:
    # Decorator as an instance method
    def decorator1(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(&#39;Decorator 1&#39;)
            return func(*args, **kwargs)
        return wrapper

    # Decorator as a class method
    @classmethod
    def decorator2(cls, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(&#39;Decorator 2&#39;)
            return func(*args, **kwargs)
        return wrapper
</code></pre>

<h2 id="toc_21">模块</h2>

<h3 id="toc_22">模块导入</h3>

<pre><code class="language-python">import mod_name #引入模块
import m as k #引入后重命名
from m import func1 #引入m模块的func1方法
from m import * #从m中引入所有对象
</code></pre>

<h3 id="toc_23">模块调用</h3>

<p>mod.obj</p>

<h3 id="toc_24">模块搜索路径</h3>

<ol>
<li>程序所在目录</li>
<li>标准库的安装路径</li>
<li>操作系统环境变量PYTHONPATH的路径</li>
</ol>

<h3 id="toc_25">构建模块</h3>

<h3 id="toc_26">常用标准库</h3>

<ul>
<li>正则<code>re</code></li>
<li>时间与日期<code>time</code> <code>datetime</code></li>
<li>路径与文件<code>os.path</code> <code>glob</code></li>
<li>文件管理 <code>os</code> <code>shutil</code></li>
<li>存储对象 <code>pickle</code> <code>cPickle</code></li>
<li>子进程 <code>subprocess</code></li>
<li>信号 <code>signal</code></li>
<li>线程同步 <code>threading</code></li>
<li>进程信息 <code>os</code></li>
<li>多进程 <code>multiprocessing</code></li>
<li>数学 <code>math</code></li>
<li>随机数 <code>random</code></li>
<li>循环器 <code>itertools</code></li>
<li>数据库 <code>sqlite3</code></li>
<li><a href="https://docs.python.org/2/library">python2 more library</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在mac mini上安装CentOS7]]></title>
    <link href="http://blog.cxstars.com/14842192746625.html"/>
    <updated>2017-01-12T19:07:54+08:00</updated>
    <id>http://blog.cxstars.com/14842192746625.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">下载mini iso</h2>

<p><a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso">CentOS7 mini</a></p>

<h2 id="toc_1">格式化</h2>

<p><code>hdiutil convert -format UDRW -o ~/Downloads/CentOS-7-x86_64-Minimal-1611.img ~/Downloads/CentOS-7-x86_64-Minimal-1611.iso</code></p>

<p>输出:</p>

<pre><code class="language-shell">正在读取Master Boot Record（MBR：0）…
正在读取CentOS 7 x86_64                 （Apple_ISO：1）…
正在读取（Type EF：2）…
.
正在读取CentOS 7 x86_64                 （Apple_ISO：3）…
..............................................................................................................................................................................................
已耗时： 3.125s
速度：217.6M 字节/秒
节省：0.0%
created: /Users/star/Downloads/CentOS-7-x86_64-Minimal-1611.img.dmg
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_2">查看U盘并写入系统</h2>

<p>查看U盘设备信息:<br/>
<code>diskutil list</code><br/>
输出:</p>

<pre><code class="language-shell">/dev/disk0 (internal, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:      GUID_partition_scheme                        *500.3 GB   disk0
   1:                        EFI EFI                     209.7 MB   disk0s1
   2:          Apple_CoreStorage Macintosh HD            499.4 GB   disk0s2
   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3

/dev/disk1 (internal, virtual):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:                            Macintosh HD           +499.1 GB   disk1
                                 Logical Volume on disk0s2
                                 BD5527E2-7278-4078-90AD-0103839D6A6C
                                 Unlocked Encrypted

/dev/disk2 (external, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:     FDisk_partition_scheme                        *4.0 GB     disk2
   1:                 DOS_FAT_32 LDANE                   4.0 GB     disk2s1
</code></pre>

<p>卸载U盘挂载:<br/>
<code>diskutil unmountDisk /dev/disk2</code></p>

<p>输出:<br/>
<code>Unmount of all volumes on disk2 was successful</code></p>

<p>写入系统:<br/>
<code>sudo dd if=~/Downloads/CentOS-7-x86_64-Minimal-1611.img.dmg of=/dev/disk2 bs=1m</code><br/>
做个安静等待的美男子.</p>

<h2 id="toc_3">进入系统</h2>

<p>按<code>option</code>键进入界面后选择<code>EFI</code>进入系统.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swoole安装]]></title>
    <link href="http://blog.cxstars.com/14840656639167.html"/>
    <updated>2017-01-11T00:27:43+08:00</updated>
    <id>http://blog.cxstars.com/14840656639167.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">下载源码</h2>

<p><a href="https://git.oschina.net/matyhtf/swoole.git">swoole oschina link</a></p>

<h2 id="toc_1">在mac下编译</h2>

<h3 id="toc_2">编译swoole</h3>

<pre><code class="language-bash">cd swoole-src
phpize
./configure
make
sudo make install
</code></pre>

<h3 id="toc_3">添加扩展至php.ini</h3>

<p><code>extension=/usr/local/php/lib/php/extensions/debug-zts-20131226/swoole.so</code></p>

<h3 id="toc_4">查看phpinfo</h3>

<p><img src="http://ojaief5u9.bkt.clouddn.com/2017-01-11-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-07%2018.06.51.png" alt="phpinfo show swoole extension"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swoole学习记录]]></title>
    <link href="http://blog.cxstars.com/14840656459705.html"/>
    <updated>2017-01-11T00:27:25+08:00</updated>
    <id>http://blog.cxstars.com/14840656459705.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">定时器</h2>

<p><strong>swoole_timer_tick</strong>重复执行指定方法,<strong>swoole_timer_after</strong>延迟指定时间后执行<em>callback method</em></p>

<pre><code class="language-php">$tick_timer_id = swoole_timer_tick(1000,function($timer_id){
       echo &#39;same as setInterval.And this timer id :&#39;.$timer_id.PHP_EOL;
    });
var_dump($tick_timer_id);
swoole_timer_after(2000,function(){
   echo &#39;same as setTimeout&#39;.PHP_EOL;
});
swoole_timer_clear($tick_timer_id);
</code></pre>

<h2 id="toc_1">异步任务</h2>

<pre><code class="language-php">$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501);
//设置异步任务的工作进程数量
$serv-&gt;set(array(&#39;task_worker_num&#39; =&gt; 4));
$serv-&gt;on(&#39;receive&#39;, function($serv, $fd, $from_id, $data) {
    //投递异步任务
    $task_id = $serv-&gt;task($data);
    echo &quot;Dispath AsyncTask: id=${task_id}\n&quot;;
});
//处理异步任务
$serv-&gt;on(&#39;task&#39;, function ($serv, $task_id, $from_id, $data) {
    echo &quot;New AsyncTask[id=$task_id]&quot;.PHP_EOL;
    //返回任务执行的结果
//    $serv-&gt;finish(&quot;$data -&gt; OK&quot;);
});
//处理异步任务的结果
$serv-&gt;on(&#39;finish&#39;, function ($serv, $task_id, $data) {
    echo &quot;AsyncTask[$task_id] Finish: $data&quot;.PHP_EOL;
});
$serv-&gt;start();
</code></pre>

<h2 id="toc_2">协议</h2>

<blockquote>
<p>因为TCP通信是流式的，在接收1个大数据包时，可能会被拆分成多个数据包发送。多次Send底层也可能会合并成一次进行发送。这里就需要2个操作来解决：</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>分包：Server收到了多个数据包，需要拆分数据包<br/>
合包：Server收到的数据只是包的一部分，需要缓存数据，合并成完整的包</p>

<h3 id="toc_3">EOF协议</h3>

<p>EOF协议处理的原理是每个数据包结尾加一串特殊字符表示包已结束。如memcache、ftp、stmp都使用\r\n作为结束符。发送数据时只需要在包末尾增加\r\n即可。使用EOF协议处理，一定要确保数据包中间不会出现EOF，否则会造成分包错误。</p>

<p>在swoole_server和swoole_client的代码中只需要设置2个参数就可以使用EOF协议处理。</p>

<pre><code class="language-php">$server-&gt;set(array(
    &#39;open_eof_split&#39; =&gt; true,
    &#39;package_eof&#39; =&gt; &quot;\r\n&quot;,
));
$client-&gt;set(array(
    &#39;open_eof_split&#39; =&gt; true,
    &#39;package_eof&#39; =&gt; &quot;\r\n&quot;,
));
</code></pre>

<h2 id="toc_4">固定包头+包头协议</h2>

<p>包头由一个字段指定了包体或整个包的长度，长度一般是使用2字节/4字节整数来表示。服务器收到包头后，可以根据长度值来精确控制需要再接收多少数据就是完整的数据包。<br/>
Swoole的Server和异步Client都是在<em>onReceive</em>回调函数中处理数据包，当设置了协议处理后，只有收到一个完整数据包时才会触发<em>onReceive</em>事件。同步客户端在设置了协议处理后，调用 $client-&gt;recv() 不再需要传入长度，recv函数在收到完整数据包或发生错误后返回。</p>

<pre><code class="language-php">$server-&gt;set(array(
    &#39;open_length_check&#39; =&gt; true,
    &#39;package_max_length&#39; =&gt; 81920,
    &#39;package_length_type&#39; =&gt; &#39;n&#39;, //see php pack()
    &#39;package_length_offset&#39; =&gt; 0,
    &#39;package_body_offset&#39; =&gt; 2,
));
</code></pre>

<h2 id="toc_5">编程注意事项</h2>

<ol>
<li>不要在代码中执行sleep以及其他睡眠函数，这样会导致整个进程阻塞exit/die是危险的，会导致worker进程退出</li>
<li>可通过register_shutdown_function来捕获致命错误，在进程异常退出时做一些请求工作，具体参看/wiki/page/305.html</li>
<li>PHP代码中如果有异常抛出，必须在回调函数中进行try/catch捕获异常，否则会导致工作进程退出</li>
<li>swoole不支持set_exception_handler，必须使用try/catch方式处理异常</li>
<li>Worker进程不得共用同一个Redis或MySQL等网络服务客户端，Redis/MySQL创建连接的相关代码可以放到onWorkerStart回调函数中，具体参考/wiki/page/325.html</li>
</ol>

<h3 id="toc_6">加载文件问题</h3>

<p>由于swoole是常驻内存的,所以加载类/函数定义的文件后不会释放。因此引入类/函数的php文件时必须要使用<strong>include_once</strong>或<strong>require_once</strong>，否会发生<code>cannot redeclare function/class</code>的致命错误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Again,Go!]]></title>
    <link href="http://blog.cxstars.com/14836808084156.html"/>
    <updated>2017-01-06T13:33:28+08:00</updated>
    <id>http://blog.cxstars.com/14836808084156.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">沉默&amp;沉淀</h2>

<p>再次记录自己的心路历程,不论是生活还是工作.总担心自己什么时候连自己都忘了的家伙.</p>

<h2 id="toc_1">Mac&amp;Mweb</h2>

<p>使用MWeb进行写作.记录一下常用的快捷键,顺便熟悉一下MWeb.</p>

<h2 id="toc_2">MWEB MapKey</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>CTL+1</td>
<td>标题1</td>
</tr>
<tr>
<td>CTL+2</td>
<td>标题2</td>
</tr>
<tr>
<td>CTL+3</td>
<td>标题3</td>
</tr>
<tr>
<td>CTL+4</td>
<td>标题4</td>
</tr>
<tr>
<td>CTL+5</td>
<td>标题5</td>
</tr>
<tr>
<td>CTL+6</td>
<td>标题6</td>
</tr>
<tr>
<td>CMD+B</td>
<td><strong>粗体</strong></td>
</tr>
<tr>
<td>CMD+U</td>
<td><u>下划线</u></td>
</tr>
<tr>
<td>CMD+I</td>
<td><em>斜体</em></td>
</tr>
<tr>
<td>CMD+-</td>
<td><del>删除线</del></td>
</tr>
<tr>
<td>CMD+=</td>
<td><mark>高亮</mark></td>
</tr>
<tr>
<td>CMD+K</td>
<td>行内代码</td>
</tr>
<tr>
<td>CMD+/</td>
<td>注释</td>
</tr>
<tr>
<td>CMD+.</td>
<td>阅读更多</td>
</tr>
<tr>
<td>CTL+U</td>
<td>无序列表</td>
</tr>
<tr>
<td>CMD+SFT+O</td>
<td>有序列表</td>
</tr>
<tr>
<td>CMD+SFT+B</td>
<td>引用</td>
</tr>
<tr>
<td>CMD+]</td>
<td>左移</td>
</tr>
<tr>
<td>CMD+[</td>
<td>右移</td>
</tr>
<tr>
<td>CTL+SFT+L</td>
<td>链接</td>
</tr>
<tr>
<td>CTL+SFT+T</td>
<td>表格</td>
</tr>
<tr>
<td>CTL+SFT+I</td>
<td>图片</td>
</tr>
<tr>
<td>CMD+OPT+I</td>
<td>插入本地图片</td>
</tr>
<tr>
<td>CMD+ENT</td>
<td>新段落</td>
</tr>
<tr>
<td>CMD+SFT+E</td>
<td>焦点至编辑器</td>
</tr>
<tr>
<td>CMD+SFT+F</td>
<td>焦点至搜索栏</td>
</tr>
<tr>
<td>CMD+7</td>
<td>大纲(目录)</td>
</tr>
<tr>
<td>CMD+8</td>
<td>文件信息</td>
</tr>
<tr>
<td>CMD+9</td>
<td>导出/发布</td>
</tr>
<tr>
<td>CMD+E</td>
<td>外部模式(打开现有的文件[夹])</td>
</tr>
<tr>
<td>CMD+E</td>
<td>文档库模式</td>
</tr>
<tr>
<td>CMD+R</td>
<td>预览</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue-review]]></title>
    <link href="http://blog.cxstars.com/14836103185566.html"/>
    <updated>2017-01-05T17:58:38+08:00</updated>
    <id>http://blog.cxstars.com/14836103185566.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>从今天(2016-05-26)开始，新一轮APUE浏览，期望最近就foucs它了，同人交流后才发现了解归了解，能不能讲明白又是另一个等级的事了。SO,打怪涨经验升级。 </p>
</blockquote>

<h2 id="toc_0">源码编译</h2>

<p>mac下直接make就ok，ubuntu稍微麻烦一点。<br/>
我看的是apue第三版英文版，先将PDF分享出来，有需要的可以下。<br/>
 (apue)[<a href="http://pan.baidu.com/s/1gfsaTk3">http://pan.baidu.com/s/1gfsaTk3</a>] 提取码<em>ivxs</em> </p>

<h2 id="toc_1">CPU的内核态和用户态</h2>

<p>只有执行硬件命令才可以例CPU在这两种状态间来回切换。根本区别就是用户态只能操作虚拟内存中被标记为用户内存的区域，而内核态则可以操作所有内存。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_2">文件IO模型</h2>

<p>就本质而言，内核只提供了一种文件类型：字节流序列。<br/>
在处理磁盘文件、磁盘或者磁带设备时，可以通过lseek()系统调用来随机访问。</p>

<h2 id="toc_3">进程的内存布局</h2>

<p>逻辑上将一个进程分为以下几段：<br/>
- 文本：程序的指令<br/>
- 数据：程序使用的静态变量<br/>
- 堆：程序可以从该区域动态分配额外内存<br/>
- 栈：随函数调用、返回而增加减少的一片内存区域，用于为局部变量和函数调用链接信息分配存储空间</p>

<h2 id="toc_4">内存映射</h2>

<ul>
<li>文件映射 </li>
<li>匿名映射</li>
</ul>

<h2 id="toc_5">进程间通讯及同步（七种方式）</h2>

<ul>
<li>信号(signal)，表示事件的发生</li>
<li>管理和FIFO，用于在进程间传递数据 </li>
<li>套接字，可以跨主机进程通讯</li>
<li>文件锁定，为防止其他进程读取或者更新文件内容，允许某进程对文件的部分区域加以锁定</li>
<li>消息队列，用于在进程间交换消息(数据包)</li>
<li>信号量（semaphore），用来同步进程动作</li>
<li>共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化</li>
</ul>

<h2 id="toc_6">进程和线程复制</h2>

<p>进程：fork进程会产生新的进程，会复制父进程的堆、栈、数据段。<br/>
线程：每个线程都会执行相同的程序代码，共享同一数据区域和堆。但是，每个线程都有属于自己的栈，用来半截本地变量和函数调用链接信息。</p>

<h2 id="toc_7">线程的优点</h2>

<blockquote>
<p>协同线程之间的数据共享(通过全局变量)更为容易，而且就某些算法而言，以多线程来实现要比之以多进程实现要更加自然，而且能从压榨多核处理器的计算力。</p>
</blockquote>

<h2 id="toc_8">问题</h2>

<ul>
<li>文件空洞到底是什么？core dump？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[soa-architecture-overview]]></title>
    <link href="http://blog.cxstars.com/14836102763553.html"/>
    <updated>2017-01-05T17:57:56+08:00</updated>
    <id>http://blog.cxstars.com/14836102763553.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">什么是SOA</h2>

<blockquote>
<p>面向服务的体系结构（英语：service-oriented architecture）是构造分布式计算的应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。</p>

<p>企业系统的架构师认为SOA能够帮助业务迅速和高效地响应变化的市场条件. 服务导向的架构在宏观（服务）上，而不是在微观上（对象）因此提高了重复使用性。同时，服务导向的架构可以简化与传统系统的互连和使用。</p>
</blockquote>

<h2 id="toc_1">SOA Principle</h2>

<ul>
<li>可重复使用，粒度，模组性，可组合型，物件化原件，构件化以及具交互操作性</li>
<li>符合开放标准（通用的或者行业的）</li>
<li>服务的识别和分类，提供和发布，监控和跟踪</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_2">RPC - Remote Process Call</h2>

<blockquote>
<p>RPC使用C/S方式，采用http协议,发送请求到服务器，等待服务器返回结果。这个请求包括一个参数集和一个文本集，通常形成“classname.methodname”形式。优点是跨语言跨平台，C端、S端有更大的独立性，缺点是<em>不支持对象，无法在编译器检查错误，只能在运行期检查</em>。</p>
</blockquote>

<h2 id="toc_3">RMI - Remote Method Ivocation</h2>

<blockquote>
<p>TCP协议。采用stubs 和 skeletons 来进行远程对象(remote object)的通讯。stub 充当远程对象的客户端代理，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端代理对象stub来完成的，通过该机制RMI就好比它是本地工作，采用tcp/ip协议，客户端直接调用服务端上的一些方法。优点是强类型，编译期可检查错误，缺点是只能基于JAVA语言，客户机与服务器紧耦合。</p>
</blockquote>

<h2 id="toc_4">Architecture 架构</h2>

<blockquote>
<p>分析就是做正确的事，设计就是正确的做事。架构跟语言跟平台关系不大，毕竟架构是设计过程中的子过程，我想如果你的设计不合理，你用任何语言任何平台都解决不了问题。</p>
</blockquote>

<h2 id="toc_5">GRASP - General Responsibility Assignment Software Patterns（通用职责分配软件模式）</h2>

<blockquote>
<p>GRASP一共包括9种模式，它们描述了对象设计和职责分配的基本原则。如何把现实世界的业务功能抽象成对象，如何决定一个系统有多少对象，每个对象都包括什么职责，GRASP模式给出了最基本的指导原则。</p>
</blockquote>

<p><em>2016-05-26</em> </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[serverh-on-redis-source-code]]></title>
    <link href="http://blog.cxstars.com/14836102159997.html"/>
    <updated>2017-01-05T17:56:55+08:00</updated>
    <id>http://blog.cxstars.com/14836102159997.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">server.h on redis source code</h1>

<h2 id="toc_1">directory</h2>

<ul>
<li><code>src</code>:包括了所有Redis的c实现源文件</li>
<li><code>tests</code>:包括了所有的Redis单元测试文件，有Redis、Redis Cluster、Redis Sentinel，使用tcl(<em>Sentinel</em>)实现</li>
<li><code>deps</code>:包括了Redis所有要用的库，你只需要提供<code>libc</code>和一个c编译器。<code>deps</code>下大多数的功能都是开始于<em>Redis</em>，也有一个例外：<code>geohash-int</code></li>
</ul>

<h2 id="toc_2">server.h</h2>

<blockquote>
<p>在Redis3.0的unstable分支中全名为<code>redis.h</code>和<code>redis.c</code>。想要理解Redis是如何工作的，就要先理解它所用的数据结构。<br/>
<code>struct redisServer</code>里包含了所有redis server的配置。以下是几个重要的字段：</p>
</blockquote>

<span id="more"></span><!-- more -->

<ul>
<li><code>server.db</code>Redis Databases数组，存储数据的地主</li>
<li><code>server.commands</code>是所支持的命令表</li>
<li><code>server.clients</code>已连接server的Redsi Client链表</li>
<li><code>server.master</code>是一个特殊客户端,如果实例是从服务,则为主服务器的客户端</li>
</ul>

<blockquote>
<p>另一个非常重要的Redis数据结构是client的定义，以前定义为redisClient。</p>
</blockquote>

<p>这个结构定义了这么多字段，这里只展示只个重要的字符：</p>

<pre><code class="language-c">struct client {
int fd;
sds querybuf;
int argc;
robj \*\*argv;
redisDb \*db;
int flags;
list \*reply;
char buf[PROTO\_REPLY\_CHUNK\_BYTES];
... many other fields ...
}
</code></pre>

<p>client结构定义了一个已连接Redis客户端：<br/>
* <code>fd</code>是客户端的socket描述符<br/>
* <code>argc</code>和<code>argv</code>是客户端执行命令时的参数，执行方法实现了给定Redis命令读取参数。<br/>
* <code>querybuf</code>是从客户端积累的请求，它们将被Redis Server通过Redis protocol解析并执行客户端命令的实现。<br/>
* <code>reply</code>和<code>buf</code>是Redis Server执行命令后返回给客户端的动态、静态缓存。当文件描述符可写，这些缓存就增量的写进socket<br/>
就像你看到的，在client结构体的上方，就是命令参数的结构体<code>robj</code>。下面是<code>robj</code>的所有结构，它被定义为<em>Redis Object</em>对象:</p>

<pre><code class="language-c">typedef struct redisObject {
unsigned type:4;
unsigned encoding:4;
unsigned lru:LRU\_BITS; /* lru time (relative to server.lruclock) */
int refcount;
void \*ptr;
} robj;

</code></pre>

<p>基本上这个结构就可以代表所有Redis的基本数据结构，比如strings,lists,sets,sorted,sets等等。有趣的是它有一个<code>type</code>字段，所以可以知道是一个什么类型的对象。<code>refcount</code>可以关联好几个地方的同一个对象而不用再重新分配内存。最后<code>ptr</code>指针指向对象的实际地址，即使是同类型，根据<code>encoding</code>字段这个值也可能是不同的。</p>

<p>在Redis的内部，Redis Object使用得非常广泛，然后为了避免过于迂回的访问方式，最近我们在许多地方使用单纯的动态字符串，而不是将它包装进Redis Ojbect。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[golang send a https request and skip the certificate]]></title>
    <link href="http://blog.cxstars.com/14836098881938.html"/>
    <updated>2017-01-05T17:51:28+08:00</updated>
    <id>http://blog.cxstars.com/14836098881938.html</id>
    <content type="html"><![CDATA[
<p>使用<code>crypto/tls</code>包</p>

<blockquote>
<p>官网对包的说明:Package tls partially implements TLS 1.2, as specified in RFC 5246.</p>
</blockquote>

<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;net/http&quot;
        &quot;crypto/tls&quot;
       )

func main() {
 tr := &amp;http.Transport{
            TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},

}
        client := &amp;http.Client{Transport: tr}
                _, err := client.Get(&quot;https://golang.org/&quot;)
                    if err != nil {
                                    fmt.Println(err)

                    }

}
</code></pre>

]]></content>
  </entry>
  
</feed>
